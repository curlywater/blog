(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{450:function(v,_,t){"use strict";t.r(_);var l=t(18),e=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"递归"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#递归"}},[v._v("#")]),v._v(" 递归")]),v._v(" "),t("p",[v._v("适用递归的场景：")]),v._v(" "),t("ol",[t("li",[v._v("一个问题的可以分解为几个子问题的解")]),v._v(" "),t("li",[v._v("父问题和子问题求解思路完全一致")]),v._v(" "),t("li",[v._v("存在递归终止条件")])]),v._v(" "),t("p",[v._v("递归的实现思路：")]),v._v(" "),t("ol",[t("li",[v._v("只考虑一层中问题和子问题的联系，抽象成递推公式")]),v._v(" "),t("li",[v._v("找到终止条件")])]),v._v(" "),t("p",[v._v("递归存在的问题：")]),v._v(" "),t("ol",[t("li",[v._v("调用栈溢出 -> 限制递归深度")]),v._v(" "),t("li",[v._v("如果存在环，会导致死循环")]),v._v(" "),t("li",[v._v("重复计算 -> 保存已计算值")]),v._v(" "),t("li",[v._v("空间复杂度")])]),v._v(" "),t("p",[v._v("递归代码可以改为迭代循环的非递归写法。")]),v._v(" "),t("blockquote",[t("p",[v._v("因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。")])])])}),[],!1,null,null,null);_.default=e.exports}}]);