(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{453:function(e,t,r){"use strict";r.r(t);var o=r(18),_=Object(o.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"算法思维：贪心、分治、回溯、动态规划"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#算法思维：贪心、分治、回溯、动态规划"}},[e._v("#")]),e._v(" 算法思维：贪心、分治、回溯、动态规划")]),e._v(" "),r("h2",{attrs:{id:"贪心算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法"}},[e._v("#")]),e._v(" 贪心算法")]),e._v(" "),r("p",[e._v("顾名思义，贪心即每一次都做收益率最大的选择。")]),e._v(" "),r("p",[e._v("应用场景：使具有"),r("strong",[e._v("限制值")]),e._v("和"),r("strong",[e._v("期望值")]),e._v("。要求在满足限制值的情况下，获取最大期望值。")]),e._v(" "),r("p",[e._v("核心思想：每次选择时，选择能以最小代价得到相同期望值的选项。")]),e._v(" "),r("p",[e._v("验证：贪心每次选择当前最优项，但不一定是广义的最优解，因此需要进行例举验证。")]),e._v(" "),r("p",[e._v("难点：将要解决的问题抽象成贪心算法模型。")]),e._v(" "),r("p",[r("strong",[e._v("练习")])]),e._v(" "),r("p",[r("a",{attrs:{href:"https://leetcode-cn.com/problems/assign-cookies/",target:"_blank",rel:"noopener noreferrer"}},[e._v("分发饼干"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://leetcode-cn.com/problems/maximum-subarray/",target:"_blank",rel:"noopener noreferrer"}},[e._v("最大子序和"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://leetcode-cn.com/problems/gas-station/",target:"_blank",rel:"noopener noreferrer"}},[e._v("加油站"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://leetcode-cn.com/problems/queue-reconstruction-by-height/",target:"_blank",rel:"noopener noreferrer"}},[e._v("根据身高重建队列"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/",target:"_blank",rel:"noopener noreferrer"}},[e._v("用最少数量的箭引爆气球"),r("OutboundLink")],1)]),e._v(" "),r("h2",{attrs:{id:"分治"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分治"}},[e._v("#")]),e._v(" 分治")]),e._v(" "),r("p",[e._v("分而治之。")]),e._v(" "),r("p",[e._v("拆分为子问题 -> 子问题求解 -> 将子问题合并为原问题的解。")]),e._v(" "),r("p",[e._v("应用场景：")]),e._v(" "),r("ol",[r("li",[e._v("原问题与分解成的小问题具有相同的模式；")]),e._v(" "),r("li",[e._v("原问题分解成的子问题可以独立求解，子问题之间没有相关性")]),e._v(" "),r("li",[e._v("具有分解终止条件")]),e._v(" "),r("li",[e._v("可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。")])]),e._v(" "),r("blockquote",[r("p",[e._v("创新并非离我们很远，创新的源泉来自对事物本质的认识。无数优秀架构设计的思想来源都是基础的数据结构和算法，这本身就是算法的一个魅力所在。")])]),e._v(" "),r("p",[r("strong",[e._v("练习")])]),e._v(" "),r("p",[r("a",{attrs:{href:"https://leetcode-cn.com/problems/majority-element/",target:"_blank",rel:"noopener noreferrer"}},[e._v("多数元素"),r("OutboundLink")],1)]),e._v(" "),r("h2",{attrs:{id:"回溯"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回溯"}},[e._v("#")]),e._v(" 回溯")]),e._v(" "),r("p",[e._v("面对岔路口时，随意选择一条路，当发现这条路走不通的时候，就回退到上一个岔路口，另选一种走法继续走。")]),e._v(" "),r("p",[e._v("递归：回溯算法非常适合用递归来实现")]),e._v(" "),r("p",[e._v("剪枝：在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。")]),e._v(" "),r("p",[e._v("回溯的经典问题：")]),e._v(" "),r("p",[e._v("深度优先搜索、八皇后、0-1 背包问题、图的着色、旅行商问题、数独、全排列、正则表达式匹配")])])}),[],!1,null,null,null);t.default=_.exports}}]);