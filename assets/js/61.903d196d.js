(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{449:function(t,s,a){"use strict";a.r(s);var e=a(18),c=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"基础数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础数据结构"}},[t._v("#")]),t._v(" 基础数据结构")]),t._v(" "),a("h2",{attrs:{id:"数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),a("p",[a("strong",[t._v("线性表数据结构")])]),t._v(" "),a("p",[t._v("只有前后两个方向")]),t._v(" "),a("p",[a("strong",[t._v("存储方式")])]),t._v(" "),a("p",[t._v("连续内存空间，相同类型的数据寻址方式"),a("code",[t._v("base_address + i * data_type_size")]),t._v("。")]),t._v(" "),a("p",[t._v("容器：支持动态扩容，重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。")]),t._v(" "),a("p",[a("strong",[t._v("时间复杂度")])]),t._v(" "),a("p",[t._v("数组支持随机访问，根据下标随机访问的时间复杂度为 "),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:" MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"O"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:"("}})],1),a("mjx-mn",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:"1"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:")"}})],1)],1)],1)],1),t._v(" "),a("p",[t._v("插入/删除平均时间复杂度 "),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:" MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"O"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:"("}})],1),a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"n"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:")"}})],1)],1)],1)],1),t._v(" "),a("h2",{attrs:{id:"链表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[t._v("#")]),t._v(" 链表")]),t._v(" "),a("p",[t._v("无需连续内存，它通过“指针”将一组零散的内存块串联起来使用")]),t._v(" "),a("p",[t._v("单链表\n"),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg",alt:""}})]),t._v(" "),a("p",[t._v("循环链表\n"),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg",alt:""}})]),t._v(" "),a("p",[t._v("双向链表\n"),a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg",alt:""}})]),t._v(" "),a("p",[t._v("双向循环链表")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg",alt:""}})]),t._v(" "),a("p",[a("strong",[t._v("时间复杂度")])]),t._v(" "),a("p",[t._v("随机访问："),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:" MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"O"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:"("}})],1),a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"n"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:")"}})],1)],1)],1)],1),t._v(" "),a("p",[t._v("插入/删除结点中“值等于某个给定值”的结点："),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:" MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"O"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:"("}})],1),a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"n"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:")"}})],1)],1)],1)],1),t._v(" "),a("p",[t._v("插入/删除给定指针指向的结点。单链表"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:" MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"O"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:"("}})],1),a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"n"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:")"}})],1)],1)],1),t._v("，双向链表"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:" MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"O"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:"("}})],1),a("mjx-mn",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:"1"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:")"}})],1)],1)],1)],1),t._v(" "),a("p",[t._v("双向链表需要更多的内存空间，但在一些操作场景中可以提高代码运行效率。")]),t._v(" "),a("p",[t._v("对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。")]),t._v(" "),a("p",[a("strong",[t._v("和数组对比")])]),t._v(" "),a("p",[t._v("数组：访问效率高，大小固定，扩容代价")]),t._v(" "),a("p",[t._v("链表：内存消耗翻倍，频繁操作，内存碎片，频繁GC")]),t._v(" "),a("p",[a("strong",[t._v("编程技巧")])]),t._v(" "),a("ol",[a("li",[t._v("设置哨兵，将第一个结点和最后一个结点插入/删除的特殊情况一致化处理")]),t._v(" "),a("li",[t._v("检查边界条件：\n"),a("ol",[a("li",[t._v("空链表的执行情况")]),t._v(" "),a("li",[t._v("只包含一个结点")]),t._v(" "),a("li",[t._v("只包含两个结点")]),t._v(" "),a("li",[t._v("处理头结点和尾结点")])])])]),t._v(" "),a("p",[a("strong",[t._v("练习")])]),t._v(" "),a("ul",{staticClass:"contains-task-list"},[a("li",{staticClass:"task-list-item"},[a("input",{staticClass:"task-list-item-checkbox",attrs:{checked:"",disabled:"",type:"checkbox"}}),t._v(" "),a("a",{attrs:{href:"https://leetcode-cn.com/problems/reverse-linked-list/",target:"_blank",rel:"noopener noreferrer"}},[t._v("单链表反转"),a("OutboundLink")],1),t._v(" "),a("Tag",[t._v("链表操作")])],1),t._v(" "),a("li",{staticClass:"task-list-item"},[a("input",{staticClass:"task-list-item-checkbox",attrs:{checked:"",disabled:"",type:"checkbox"}}),t._v(" "),a("a",{attrs:{href:"https://leetcode-cn.com/problems/linked-list-cycle/",target:"_blank",rel:"noopener noreferrer"}},[t._v("链表中环的检测"),a("OutboundLink")],1),t._v(" "),a("Tag",[t._v("快慢指针")])],1),t._v(" "),a("li",{staticClass:"task-list-item"},[a("input",{staticClass:"task-list-item-checkbox",attrs:{checked:"",disabled:"",type:"checkbox"}}),t._v(" "),a("a",{attrs:{href:"https://leetcode-cn.com/problems/merge-two-sorted-lists/",target:"_blank",rel:"noopener noreferrer"}},[t._v("两个有序的链表合并"),a("OutboundLink")],1),t._v(" "),a("Tag",[t._v("链表操作")]),a("Tag",[t._v("哨兵")])],1),t._v(" "),a("li",{staticClass:"task-list-item"},[a("input",{staticClass:"task-list-item-checkbox",attrs:{checked:"",disabled:"",type:"checkbox"}}),t._v(" "),a("a",{attrs:{href:"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/",target:"_blank",rel:"noopener noreferrer"}},[t._v("删除链表倒数第 n 个结点"),a("OutboundLink")],1),t._v(" "),a("Tag",[t._v("快慢指针")]),a("Tag",[t._v("哨兵")])],1),t._v(" "),a("li",{staticClass:"task-list-item"},[a("input",{staticClass:"task-list-item-checkbox",attrs:{checked:"",disabled:"",type:"checkbox"}}),t._v(" "),a("a",{attrs:{href:"https://leetcode-cn.com/problems/middle-of-the-linked-list/",target:"_blank",rel:"noopener noreferrer"}},[t._v("求链表的中间结点"),a("OutboundLink")],1),t._v(" "),a("Tag",[t._v("快慢指针")])],1),t._v(" "),a("li",{staticClass:"task-list-item"},[a("input",{staticClass:"task-list-item-checkbox",attrs:{checked:"",disabled:"",type:"checkbox"}}),t._v(" "),a("a",{attrs:{href:"https://leetcode-cn.com/problems/palindrome-linked-list/",target:"_blank",rel:"noopener noreferrer"}},[t._v("使用单链表判断回文串"),a("OutboundLink")],1),t._v(" "),a("Tag",[t._v("快慢指针")]),a("Tag",[t._v("链表操作")])],1),t._v(" "),a("li",{staticClass:"task-list-item"},[a("input",{staticClass:"task-list-item-checkbox",attrs:{checked:"",disabled:"",type:"checkbox"}}),t._v(" "),a("a",{attrs:{href:"https://leetcode-cn.com/problems/lru-cache-lcci/",target:"_blank",rel:"noopener noreferrer"}},[t._v("使用单链表实现LRU"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),a("p",[t._v("适用于只需一端插入和删除数据，满足先进后出特性的场景。")]),t._v(" "),a("p",[t._v("栈可以由数组或链表实现。")]),t._v(" "),a("blockquote",[a("p",[t._v("事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。")])]),t._v(" "),a("p",[t._v("动态扩容栈的均摊复杂度"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:" MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"O"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:"("}})],1),a("mjx-mn",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:"1"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:")"}})],1)],1)],1)],1),t._v(" "),a("p",[t._v("栈的应用场景：")]),t._v(" "),a("ol",[a("li",[t._v("函数调用栈")]),t._v(" "),a("li",[t._v("表达式求值：操作数栈和运算符栈，操作数压栈，运算符比较运算符栈内优先级，计算后再压栈")]),t._v(" "),a("li",[t._v("括号匹配")]),t._v(" "),a("li",[t._v("浏览器前进后退功能：当前访问路径栈和历史访问栈，后退时将当前页面压入历史访问栈，当跳转到新的页面清空历史访问栈")])]),t._v(" "),a("p",[a("strong",[t._v("练习")])]),t._v(" "),a("ul",{staticClass:"contains-task-list"},[a("li",{staticClass:"task-list-item"},[a("input",{staticClass:"task-list-item-checkbox",attrs:{checked:"",disabled:"",type:"checkbox"}}),t._v(" "),a("a",{attrs:{href:"https://leetcode-cn.com/problems/valid-parentheses/",target:"_blank",rel:"noopener noreferrer"}},[t._v("有效括号"),a("OutboundLink")],1)]),t._v(" "),a("li",{staticClass:"task-list-item"},[a("input",{staticClass:"task-list-item-checkbox",attrs:{checked:"",disabled:"",type:"checkbox"}}),t._v(" "),a("a",{attrs:{href:"https://leetcode-cn.com/problems/min-stack/",target:"_blank",rel:"noopener noreferrer"}},[t._v("最小栈"),a("OutboundLink")],1)]),t._v(" "),a("li",{staticClass:"task-list-item"},[a("input",{staticClass:"task-list-item-checkbox",attrs:{checked:"",disabled:"",type:"checkbox"}}),t._v(" "),a("a",{attrs:{href:"https://leetcode-cn.com/problems/backspace-string-compare/",target:"_blank",rel:"noopener noreferrer"}},[t._v("比较含退格的字符串"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[t._v("#")]),t._v(" 队列")]),t._v(" "),a("p",[t._v("先进先出。")]),t._v(" "),a("p",[t._v("队列适用场景：有限资源池，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。")]),t._v(" "),a("h3",{attrs:{id:"顺序队列和链式队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#顺序队列和链式队列"}},[t._v("#")]),t._v(" 顺序队列和链式队列")]),t._v(" "),a("p",[t._v("顺序队列：数组实现的队列。队列空间有限，适合对响应时间敏感的系统。")]),t._v(" "),a("p",[t._v("链式队列：链表实现的队列。队列空间无限。")]),t._v(" "),a("h3",{attrs:{id:"线性队列和循环队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线性队列和循环队列"}},[t._v("#")]),t._v(" 线性队列和循环队列")]),t._v(" "),a("p",[a("strong",[t._v("线性队列的实现")])]),t._v(" "),a("ul",[a("li",[t._v("队头指针"),a("code",[t._v("head")]),t._v("，队尾指针"),a("code",[t._v("tail")])]),t._v(" "),a("li",[t._v("入队：队尾位置填入，队尾向后移动")]),t._v(" "),a("li",[t._v("出队：队头位置输出，队头向后移动")]),t._v(" "),a("li",[t._v("队满的判断条件："),a("code",[t._v("tail === n")])]),t._v(" "),a("li",[t._v("队空的判断条件："),a("code",[t._v("head === tail")])])]),t._v(" "),a("p",[a("strong",[t._v("循环队列的实现")])]),t._v(" "),a("ul",[a("li",[t._v("队头指针"),a("code",[t._v("head")]),t._v("，队尾指针"),a("code",[t._v("tail")])]),t._v(" "),a("li",[t._v("入队：队尾位置填入，队尾"),a("code",[t._v("(tail+1)%n")])]),t._v(" "),a("li",[t._v("出队：队头位置输出，队头"),a("code",[t._v("(head+1)%n")])]),t._v(" "),a("li",[t._v("队满的判断条件："),a("code",[t._v("(tail+1)%n === head")])]),t._v(" "),a("li",[t._v("队空的判断条件："),a("code",[t._v("head === tail")])])]),t._v(" "),a("p",[t._v("存在的问题："),a("code",[t._v("tail")]),t._v("指向尾元素后一位，浪费一个数组的存储空间。")]),t._v(" "),a("p",[t._v("方案二：使用"),a("code",[t._v("head")]),t._v("指针和队列长度"),a("code",[t._v("count")]),t._v("，计算出尾元素位置"),a("code",[t._v("tail = (head + count - 1) % n")])]),t._v(" "),a("h3",{attrs:{id:"高级队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高级队列"}},[t._v("#")]),t._v(" 高级队列")]),t._v(" "),a("p",[t._v("阻塞队列：在队列的基础上，增加阻塞操作功能。资源不足时等待，资源满足时进行操作。应用于实现生产者-消费者模型")]),t._v(" "),a("p",[t._v("并发队列：解决多线程安全性问题。最简单的实现方式是队入队/出队操作加锁，但粒度过大，因此有了CAS方法")]),t._v(" "),a("h3",{attrs:{id:"练习"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#练习"}},[t._v("#")]),t._v(" 练习")]),t._v(" "),a("ul",{staticClass:"contains-task-list"},[a("li",{staticClass:"task-list-item"},[a("input",{staticClass:"task-list-item-checkbox",attrs:{checked:"",disabled:"",type:"checkbox"}}),t._v(" "),a("a",{attrs:{href:"https://leetcode-cn.com/problems/design-circular-queue/",target:"_blank",rel:"noopener noreferrer"}},[t._v("设计循环队列"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=c.exports}}]);