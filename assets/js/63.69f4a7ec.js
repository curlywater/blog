(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{452:function(a,t,s){"use strict";s.r(t);var n=s(18),e=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"散列表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#散列表"}},[a._v("#")]),a._v(" 散列表")]),a._v(" "),s("h2",{attrs:{id:"散列表-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#散列表-2"}},[a._v("#")]),a._v(" 散列表")]),a._v(" "),s("p",[a._v("键key -> 散列函数hash(key) -> 散列值hash code")]),a._v(" "),s("p",[a._v("散列表：利用数组通过下标高效随机访问的特性。散列值对应数组下标，数组中存放信息。")]),a._v(" "),s("p",[a._v("散列函数设计的三点要求：")]),a._v(" "),s("ul",[s("li",[a._v("散列函数计算得到的散列值是一个非负整数；")]),a._v(" "),s("li",[a._v("如果 key1 = key2，那 hash(key1) == hash(key2)；")]),a._v(" "),s("li",[a._v("如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。（散列函数无法完全避免散列冲突）")])]),a._v(" "),s("h2",{attrs:{id:"散列冲突解决方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#散列冲突解决方法"}},[a._v("#")]),a._v(" 散列冲突解决方法")]),a._v(" "),s("p",[s("strong",[a._v("开放寻址法（open addressing）")])]),a._v(" "),s("p",[a._v("出现了散列冲突，我们就重新探测一个空闲位置，将其插入。\n常用探测方法：")]),a._v(" "),s("ul",[s("li",[a._v("线性探测：在循环散列表中，以步长为1向下寻址，如果定位到空闲空间，认为匹配失败")]),a._v(" "),s("li",[a._v("二次探测：步长为1，4，9，16...")]),a._v(" "),s("li",[a._v("双重散列：多个散列函数")])]),a._v(" "),s("p",[s("strong",[a._v("链表法（chaining）")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg",alt:""}})]),a._v(" "),s("h2",{attrs:{id:"如何设计散列函数？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何设计散列函数？"}},[a._v("#")]),a._v(" 如何设计散列函数？")]),a._v(" "),s("ul",[s("li",[a._v("散列函数的计算不能太复杂。")]),a._v(" "),s("li",[a._v("散列函数生成的值要尽可能随机并且均匀分布")])]),a._v(" "),s("p",[s("strong",[a._v("装载因子")])]),a._v(" "),s("p",[a._v("装载因子表示散列表中空位的多少。")]),a._v(" "),s("p",[a._v("散列表的装载因子=填入表中的元素个数/散列表的长度。")]),a._v(" "),s("p",[a._v("装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。")]),a._v(" "),s("p",[s("strong",[a._v("散列表扩容")])]),a._v(" "),s("p",[a._v("装载因子过大，导致散列冲突增多，散列表的性能下降。")]),a._v(" "),s("p",[a._v("因此，需要设置一个阈值，当散列表的装载因子超过阈值时，就需要进行扩容。")]),a._v(" "),s("p",[a._v("如果内存空间不紧张，对执行效率要求很高，可以降低阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加阈值的值，甚至可以大于 1。")]),a._v(" "),s("p",[a._v("插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。")]),a._v(" "),s("p",[a._v("在扩容时进行全迁移，会导致这一次插入操作异常卡顿。可以使用分步迁移策略分摊掉迁移成本")]),a._v(" "),s("ul",[s("li",[a._v("当装载因子触达阈值之后，只申请新空间")]),a._v(" "),s("li",[a._v("每插入一个新数据，将新数据插入新散列表，并且从旧散列表中迁移一个数据到新散列表")]),a._v(" "),s("li",[a._v("查询时，先从新散列表查找，再从旧散列表查找")])]),a._v(" "),s("p",[s("strong",[a._v("选择冲突解决方法")])]),a._v(" "),s("p",[a._v("开放寻址法，完全基于数组，因此适合数据量比较小、装载因子小的情况。")]),a._v(" "),s("p",[a._v("基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。")]),a._v(" "),s("p",[s("strong",[a._v("Java HashMap的设计")])]),a._v(" "),s("ul",[s("li",[a._v("初始大小：HashMap 默认的初始大小是 16，可根据通过具体场景自行设置")]),a._v(" "),s("li",[a._v("装载因子+动态扩容策略：最大装载因子是0.75，当 HashMap 中元素个数超过 0.75*capacity就会自动扩容，扩容为原来的两倍大小")]),a._v(" "),s("li",[a._v("冲突解决方法：使用链表法。链表长度太长（默认超过 8）时，将链表转换为红黑树；当红黑树结点小于8个，转换回链表。")]),a._v(" "),s("li",[a._v("散列函数"),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("；\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("^")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">>>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("16")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("&")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("capicity "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//capicity表示散列表的大小")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])])])])])}),[],!1,null,null,null);t.default=e.exports}}]);