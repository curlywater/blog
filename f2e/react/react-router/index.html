<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React Router 记录 | Curly的Blog</title>
    <meta name="generator" content="VuePress 1.5.3">
    <link rel="icon" href="/blog/favicon.png">
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bee8141d3226bf8abf76962d6e22700f";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <meta name="description" content="记录探索历程">
    <link rel="preload" href="/blog/assets/css/0.styles.5563ef6a.css" as="style"><link rel="preload" href="/blog/assets/js/app.41d94d83.js" as="script"><link rel="preload" href="/blog/assets/js/3.ce09a418.js" as="script"><link rel="preload" href="/blog/assets/js/38.a7a25ed2.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.e5a1f46f.js"><link rel="prefetch" href="/blog/assets/js/11.23cac595.js"><link rel="prefetch" href="/blog/assets/js/12.459bc8a4.js"><link rel="prefetch" href="/blog/assets/js/13.8452325d.js"><link rel="prefetch" href="/blog/assets/js/14.da7da709.js"><link rel="prefetch" href="/blog/assets/js/15.575f202a.js"><link rel="prefetch" href="/blog/assets/js/16.cccaed16.js"><link rel="prefetch" href="/blog/assets/js/17.f8164258.js"><link rel="prefetch" href="/blog/assets/js/18.43ebccc3.js"><link rel="prefetch" href="/blog/assets/js/19.3eace7bd.js"><link rel="prefetch" href="/blog/assets/js/20.19941b97.js"><link rel="prefetch" href="/blog/assets/js/21.ea82998b.js"><link rel="prefetch" href="/blog/assets/js/22.8e4a4dcf.js"><link rel="prefetch" href="/blog/assets/js/23.6c824cc8.js"><link rel="prefetch" href="/blog/assets/js/24.44726bc0.js"><link rel="prefetch" href="/blog/assets/js/25.9e53a540.js"><link rel="prefetch" href="/blog/assets/js/26.8b48df03.js"><link rel="prefetch" href="/blog/assets/js/27.fdbf6a61.js"><link rel="prefetch" href="/blog/assets/js/28.4f51147e.js"><link rel="prefetch" href="/blog/assets/js/29.6b40e241.js"><link rel="prefetch" href="/blog/assets/js/30.b74fb900.js"><link rel="prefetch" href="/blog/assets/js/31.37a9419d.js"><link rel="prefetch" href="/blog/assets/js/32.839d367e.js"><link rel="prefetch" href="/blog/assets/js/33.b4454420.js"><link rel="prefetch" href="/blog/assets/js/34.ad790a2f.js"><link rel="prefetch" href="/blog/assets/js/35.f838384b.js"><link rel="prefetch" href="/blog/assets/js/36.4e3750d2.js"><link rel="prefetch" href="/blog/assets/js/37.510d80ba.js"><link rel="prefetch" href="/blog/assets/js/39.5e2cb1b4.js"><link rel="prefetch" href="/blog/assets/js/4.61109045.js"><link rel="prefetch" href="/blog/assets/js/40.c857fe54.js"><link rel="prefetch" href="/blog/assets/js/41.09fe9516.js"><link rel="prefetch" href="/blog/assets/js/42.0a6e916c.js"><link rel="prefetch" href="/blog/assets/js/43.e06eaa2a.js"><link rel="prefetch" href="/blog/assets/js/44.e5199151.js"><link rel="prefetch" href="/blog/assets/js/45.bca4d4ee.js"><link rel="prefetch" href="/blog/assets/js/46.153a2ad5.js"><link rel="prefetch" href="/blog/assets/js/47.aca25b39.js"><link rel="prefetch" href="/blog/assets/js/48.32afe63e.js"><link rel="prefetch" href="/blog/assets/js/49.1a54a668.js"><link rel="prefetch" href="/blog/assets/js/5.9ffc748a.js"><link rel="prefetch" href="/blog/assets/js/50.9f06dca1.js"><link rel="prefetch" href="/blog/assets/js/51.5fa5c428.js"><link rel="prefetch" href="/blog/assets/js/52.f8155115.js"><link rel="prefetch" href="/blog/assets/js/53.ea3e39c7.js"><link rel="prefetch" href="/blog/assets/js/54.030393fe.js"><link rel="prefetch" href="/blog/assets/js/55.282fad10.js"><link rel="prefetch" href="/blog/assets/js/56.e8c06727.js"><link rel="prefetch" href="/blog/assets/js/57.10c479ab.js"><link rel="prefetch" href="/blog/assets/js/58.8f8c03c0.js"><link rel="prefetch" href="/blog/assets/js/6.25303515.js"><link rel="prefetch" href="/blog/assets/js/7.8ca2edb7.js"><link rel="prefetch" href="/blog/assets/js/8.95d4afbe.js"><link rel="prefetch" href="/blog/assets/js/9.48ece269.js"><link rel="prefetch" href="/blog/assets/js/vendors~flowchart.6dfce6e9.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.5563ef6a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Curly的Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/f2e/" class="nav-link router-link-active">
  前端技术
</a></div><div class="nav-item"><a href="/blog/algo/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/blog/explore/" class="nav-link">
  探索
</a></div><div class="nav-item"><a href="https://github.com/curlywater" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/f2e/" class="nav-link router-link-active">
  前端技术
</a></div><div class="nav-item"><a href="/blog/algo/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/blog/explore/" class="nav-link">
  探索
</a></div><div class="nav-item"><a href="https://github.com/curlywater" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/f2e/" aria-current="page" class="sidebar-link">目录</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>React</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/f2e/react/react-document/" class="sidebar-link">React知识体系</a></li><li><a href="/blog/f2e/react/react-component-lifecycle/" class="sidebar-link">React组件的生命周期</a></li><li><a href="/blog/f2e/react/react-hook/" class="sidebar-link">React Hook 使用介绍</a></li><li><a href="/blog/f2e/react/react-and-react-dom/" class="sidebar-link">React与ReactDOM分别做了什么？</a></li><li><a href="/blog/前端技术/React/少量组件应用方案.html" class="sidebar-link">少量组件应用方案</a></li><li><a href="/blog/f2e/react/react-router/" aria-current="page" class="active sidebar-link">React Router 记录</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#关于react-router-v5" class="sidebar-link">关于React Router v5</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#react-router-v4" class="sidebar-link">React Router v4</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#browserrouter" class="sidebar-link">&lt;BrowserRouter&gt;</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#hashrouter" class="sidebar-link">&lt;HashRouter&gt;</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#memoryrouter" class="sidebar-link">&lt;MemoryRouter&gt;</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#staticrouter" class="sidebar-link">&lt;StaticRouter&gt;</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#switch" class="sidebar-link">&lt;Switch&gt;</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#route" class="sidebar-link">&lt;Route&gt;</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#redirect" class="sidebar-link">&lt;Redirect&gt;</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#link" class="sidebar-link">&lt;Link&gt;</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#navlink" class="sidebar-link">&lt;NavLink&gt;</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#withrouter" class="sidebar-link">withRouter</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#usehistory" class="sidebar-link">useHistory</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#uselocation" class="sidebar-link">useLocation</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#useparams" class="sidebar-link">useParams</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#useroutematch" class="sidebar-link">useRouteMatch</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#和redux联合使用" class="sidebar-link">和Redux联合使用</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#实例分析" class="sidebar-link">实例分析</a></li><li class="sidebar-sub-header"><a href="/blog/f2e/react/react-router/#总结" class="sidebar-link">总结</a></li></ul></li></ul></li><li><a href="/blog/f2e/react/reach-router/" class="sidebar-link">Reach Router</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>模块化和构建工具</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>源码解读</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>项目记录</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-router-记录"><a href="#react-router-记录" class="header-anchor">#</a> React Router 记录</h1> <h2 id="关于react-router-v5"><a href="#关于react-router-v5" class="header-anchor">#</a> 关于React Router v5</h2> <p>在React Router v4发布两年之后，React Router开启了v5版本的开发。因为React引入hook，React Router的代码实现和行为表现也可以有新的形态。拥抱趋势，React Router v5的API将更加贴近于hook，v5版本会更接近当前Reach/Router的API形态。</p> <p><a href="https://github.com/ReactTraining/react-router/issues/6885" target="_blank" rel="noopener noreferrer">React Router v5 Roadmap<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="react-router-v4"><a href="#react-router-v4" class="header-anchor">#</a> React Router v4</h2> <p>React Router分为Core，Web，Native三部分，Core作为基础，Web/Native在基础之上根据各自载体特性增加了一些功能。</p> <p>React Route依托Lerna实现monorepo分包管理，React Route Web对应的包也就是<code>react-router-dom</code>。</p> <p>动态路由：路由、匹配器、导航都是组件，可以跟普通组件一样动态挂载。路由不再是在运行时之外静态存在，而是可以在运行过程中被动态控制。</p> <p>这里只记录要点，细节参见</p> <ul><li><a href="https://reactrouter.com/web" target="_blank" rel="noopener noreferrer">官方英文文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://itbilu.com/nodejs/npm/react-router.html" target="_blank" rel="noopener noreferrer">不错的中文文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="browserrouter"><a href="#browserrouter" class="header-anchor">#</a> <code>&lt;BrowserRouter&gt;</code></h3> <p>使用HTML5 history API实现的路由，history API提供<code>pushState/replaceState/popState</code>方法操作浏览器的浏览历史堆栈，更新地址栏，但不会向服务端发送请求。</p> <p>为了能通过url直接访问到对应页面，需要在服务器端对路由进行拦截处理。</p> <p>当React项目挂在子路径下，设置<code>basename=/xxx</code>，<code>basename</code>属性应以斜杠(/)开头，但不能以斜杠结尾。</p> <h3 id="hashrouter"><a href="#hashrouter" class="header-anchor">#</a> <code>&lt;HashRouter&gt;</code></h3> <p>使用URL Hash实现的路由，在使用上，和<code>&lt;BrowserRouter&gt;</code>相比的弊端：不支持<code>location.key</code>或<code>location.state</code>。</p> <p><code>hashType</code>属性: 用于window.location.hash的编码类型。默认：&quot;slash&quot; 。有效值为：</p> <ul><li>&quot;slash&quot; - 创建的哈希类似于：#/ and #/sunshine/lollipops</li> <li>&quot;noslash&quot; - 创建的哈希类似于：# and #sunshine/lollipops</li> <li>&quot;hashbang&quot; - 创建 “ajax crawlable” (Google弃用) 形式的哈希，类似：#!/和#!/sunshine/lollipops</li></ul> <h3 id="memoryrouter"><a href="#memoryrouter" class="header-anchor">#</a> <code>&lt;MemoryRouter&gt;</code></h3> <p>将历史记录保存在内存中，不读取或更改地址栏。在测试环境和非浏览器环境中使用。</p> <h3 id="staticrouter"><a href="#staticrouter" class="header-anchor">#</a> <code>&lt;StaticRouter&gt;</code></h3> <p>静态，即全程路由不会发生变化，适用于服务端渲染静态页面。即使匹配到了<code>&lt;Redirect&gt;</code>，也不会修改路由，而是记录到<code>context</code>中。</p> <h3 id="switch"><a href="#switch" class="header-anchor">#</a> <code>&lt;Switch&gt;</code></h3> <p>渲染唯一路由，渲染与<code>location</code>相匹配的第一个<code>&lt;Route&gt;</code>或<code>&lt;Redirect&gt;</code>子元素。</p> <p><code>&lt;Route&gt;</code>元素会使用其路径属性进行匹配，而<code>&lt;Redirect&gt;</code>元素会使用其from属性进行匹配。</p> <p>将匹配条件最宽松的<code>&lt;Route&gt;</code>放在底部，或者加上<code>exact</code>属性要求其严格匹配。</p> <h3 id="route"><a href="#route" class="header-anchor">#</a> <code>&lt;Route&gt;</code></h3> <p>单独使用<code>&lt;Route&gt;</code>，适用于包含场景，比如侧边栏组件在不同<code>location</code>都显示。</p> <p><code>&lt;Route&gt;</code>可选择三种渲染方法：</p> <ul><li><code>component: React.Component</code>：路由会使用<code>React.createElement</code>从指定的组件中创建一个新的React元素。这意味着，如果你向组件属性提供内置函数，则将在每个渲染中创建一个新组件。这将导致现有组件的卸载和新组件的安装，而不是仅更新现有组件。使用内置函数进行内联渲染时，应使用<code>render</code>或<code>children</code>属性。</li> <li><code>render: func</code>：内置渲染和包装</li> <li><code>children: func</code>：无论路由是否匹配都会进入<code>children</code>绑定函数，通过<code>match</code>获取匹配信息</li></ul> <p>三种渲染方法都会接收到三个渲染属性：</p> <ul><li><code>match</code>：包含路由与URL的匹配信息，<code>match</code>包含的字段：<div class="language-js line-numbers-mode"><pre class="language-js"><code>params<span class="token operator">:</span> object <span class="token comment">// 动态段键值对</span>
isExact<span class="token operator">:</span> boolean <span class="token comment">// 是否完全匹配</span>
path<span class="token operator">:</span> string <span class="token comment">// 当前路由的匹配模式</span>
url<span class="token operator">:</span> string <span class="token comment">// URL匹配的部分</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><code>location</code>：包含当前位置信息，<code>location</code>对象引用地址不会发生改变，因此可以在生命周期钩子中使用它来进行变更判断。<code>location</code>包含的字段：<div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">{</span>
    key<span class="token operator">:</span> <span class="token string">'ac3df4'</span><span class="token punctuation">,</span> <span class="token comment">// not with HashHistory!</span>
    pathname<span class="token operator">:</span> <span class="token string">'/somewhere'</span><span class="token punctuation">,</span>
    search<span class="token operator">:</span> <span class="token string">'?some=search-string'</span><span class="token punctuation">,</span>
    hash<span class="token operator">:</span> <span class="token string">'#howdy'</span><span class="token punctuation">,</span>
    state<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token punctuation">[</span>userDefined<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><code>history</code>：依赖于<a href="https://github.com/ReactTraining/history" target="_blank" rel="noopener noreferrer">history库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，该库实现了支持不同存储形式（history API/hash/memory）的浏览记录管理器，提供历史记录操作接口。<code>history</code>是可变的对象，因此建议直接从<code>location</code>访问当前位置信息。</li></ul> <p><code>&lt;Route&gt;</code>属性：</p> <ul><li><code>exact: boolean</code>：是否需要与<code>location.pathname</code>完全匹配</li> <li><code>strict: boolean</code>：带有斜杠的路径是否能与<code>location.pathname</code>相匹配，<code>/one</code>和<code>/one/</code>是否同等对待</li> <li><code>sensitive: boolean</code>：是否区分大小写</li></ul> <h3 id="redirect"><a href="#redirect" class="header-anchor">#</a> <code>&lt;Redirect&gt;</code></h3> <p>重定向组件，匹配到<code>from</code>部分，重定向到<code>to</code>指定的路径。</p> <p>默认会替换当前的历史记录，如果设置<code>push=true</code>，将生成新记录压栈。</p> <h3 id="link"><a href="#link" class="header-anchor">#</a> <code>&lt;Link&gt;</code></h3> <p>导航组件。</p> <ul><li><code>to: string | object | function</code></li> <li><code>replace: boolean</code></li></ul> <h3 id="navlink"><a href="#navlink" class="header-anchor">#</a> <code>&lt;NavLink&gt;</code></h3> <p>与当前URL匹配时，会为渲染的元素添加指定的样式属性。</p> <ul><li><code>activeClassName: string</code>，默认为<code>active</code></li> <li><code>activeStyle: object</code>，样式表</li> <li><code>isActive: func</code>，用于确定链接是否处于活动状态的函数</li></ul> <h3 id="withrouter"><a href="#withrouter" class="header-anchor">#</a> <code>withRouter</code></h3> <p>高阶函数，每当渲染时，withRouter都会将更新的match、location和history并传递给包装组件。</p> <p><code>Component.WrappedComponent</code>：包装的组件
<code>wrappedComponentRef: func</code>：该函数将作为<code>ref prop</code>传递给包装的组件。</p> <h3 id="usehistory"><a href="#usehistory" class="header-anchor">#</a> <code>useHistory</code></h3> <p>访问可用于导航的history实例。</p> <h3 id="uselocation"><a href="#uselocation" class="header-anchor">#</a> <code>useLocation</code></h3> <p>返回代表当前位置信息的<code>location</code>对象</p> <h3 id="useparams"><a href="#useparams" class="header-anchor">#</a> <code>useParams</code></h3> <p>访问当前<code>&lt;Route&gt;</code>的<code>match.params</code></p> <h3 id="useroutematch"><a href="#useroutematch" class="header-anchor">#</a> <code>useRouteMatch</code></h3> <p>快速使用<code>&lt;Route&gt;</code>的URL匹配功能，返回<code>match</code>信息。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useRouteMatch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react-router-dom&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">BlogPost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> match <span class="token operator">=</span> <span class="token function">useRouteMatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>path<span class="token operator">:</span> <span class="token string">&quot;/blog/:slug&quot;</span><span class="token punctuation">,</span> exact<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Do whatever you want with the match...</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>直接调用<code>useRouteMatch</code>获取当前最近Route的匹配信息。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span>url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> match<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useRouteMatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="和redux联合使用"><a href="#和redux联合使用" class="header-anchor">#</a> 和Redux联合使用</h3> <blockquote><p>Redux users: The react-router-redux package is now deprecated. See Redux Integration for a better approach.</p></blockquote> <h3 id="实例分析"><a href="#实例分析" class="header-anchor">#</a> 实例分析</h3> <p><strong><a href="https://reactrouter.com/web/example/url-params" target="_blank" rel="noopener noreferrer">URL Parameters<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>Switch<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">&quot;/:id&quot;</span> children<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>Child <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>Switch<span class="token operator">&gt;</span>


<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// We can use the `useParams` hook here to access</span>
  <span class="token comment">// the dynamic pieces of the URL.</span>
  <span class="token keyword">let</span> <span class="token punctuation">{</span> id <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h3<span class="token operator">&gt;</span><span class="token constant">ID</span><span class="token operator">:</span> <span class="token punctuation">{</span>id<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>为何函数组件Child中无法接收到<code>match/location/history</code>？</p> <p><code>&lt;Router&gt; children</code>接收一个函数没错，<code>&lt;Child /&gt;</code>实质是返回<code>React.createElement(Child, null)</code>；因此相当于<code>&lt;Route children={React.createElement(Child, null)}&gt;</code>。因此Child中无法接收到<code>Route</code>属性。</p> <p><strong><a href="https://reactrouter.com/web/example/sidebar" target="_blank" rel="noopener noreferrer">Sidebar<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong></p> <p>个人在这种场景下会选择将路由部分抽至顶层，布局部分独立组件Layout，sidebar和main作为props传入Layout。</p> <p><strong><a href="https://reactrouter.com/web/example/route-config" target="_blank" rel="noopener noreferrer">Route Config<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong></p> <p>或许可以把SubComponent中路由定义的部分抽取到RouteWithSubRoutes中，让路由层完成递归，完全封装。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>React Router v4的设计核心还是把路由和组件平等看待，也由此可以动态实现路由。在应用中，也就会出现路由混夹在组件之中的效果。和传统的静态路由管理思维是两个方向的考量。在静态路由管理中，倾向于将路由统一抽离至顶层管理。而这也是我目前习惯的，果然静态路由的设计思维还是很难改变啊。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">2020年9月4日 04:41</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/前端技术/React/少量组件应用方案.html" class="prev">
        少量组件应用方案
      </a></span> <span class="next"><a href="/blog/f2e/react/reach-router/">
        Reach Router
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.41d94d83.js" defer></script><script src="/blog/assets/js/3.ce09a418.js" defer></script><script src="/blog/assets/js/38.a7a25ed2.js" defer></script>
  </body>
</html>
