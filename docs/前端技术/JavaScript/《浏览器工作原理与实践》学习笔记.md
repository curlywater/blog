# 《浏览器工作原理与实践》学习笔记

[《浏览器工作原理与实践》](https://time.geekbang.org/column/intro/100033601)学习笔记。

## Chrome 架构：仅仅打开了 1 个页面，为什么会有 4 个进程？

进程的特点：

- 独立内存空间，进程关闭后操作系统会回收进程所占用的内存
- 可多个拥有线程
  - 一个线程崩溃，进程也崩溃
  - 线程共享进程内存空间

单进程多线程浏览器时代：所有的功能模块都在一个进程里，特点：不稳定、不流畅、不安全

多进程浏览器时代：Chrome 发布时的架构采取 1 个浏览器进程、多个渲染进程、多个插件进程，Chrome 目前的架构 1 个浏览器进程、1 个网络进程、1 个 GPU 进程、多个渲染进程、多个插件进程。渲染进程间相互独立，页面不会互相影响，对渲染进程和插件进程沙箱隔离。缺陷：更高的资源占用（每个进程都包含公共基础结构的副本），模块之间耦合性高、扩展性差。

面向服务的架构：各种模块都被定义为服务，服务可以拆分组合到不同进程中。


## TCP 协议：如何保证页面文件能被完整送达浏览器？

- 互联网中数据通过数据包传输，数据包在传输过程中容易丢失或出错
- 网络层在数据包上加上IP头（IP头包括IP版本、源IP地址、目标IP地址、生存时间信息等），通过IP地址确保数据包传输到目标主机
- UDP不提供错误包重发机制，也不验证包是否到达目的地。UDP不可靠但传的快，一般应用与游戏和视频中。传输层在数据包上加上UDP头（UDP头包括源端口号、目标主机端口号）通过端口号确保数据包传到正确的应用程序
- TCP提供重发机制，并且提供数据包排序机制把乱序的数据包重新组合成完整的原始数据，一般应用于要求数据传输可靠性的应用。传输层在数据包上加上TCP头（UDP头包括源端口号、目标主机端口号、排序序列号）通过端口号确保数据包传到正确的应用程序，通过序列好保证数据包能组合完成。
- TCP传输数据的过程：
  - 三次握手建立链接：“请求建立连接”，“已接收到请求，并同意建立连接”，“已接收到同意建立连接信号”
  - 传输数据接收端需要对每个数据包进行接收确认，发送端在规定时间内没有接收到确认信息则认为包丢失触发重发机制
  - 四次挥手断开链接：“请求释放连接”，“接收到客户端发送的释放连接请求”，“已经准备好释放连接了”，“接收到服务器准备好释放连接信号”

## HTTP请求流程：为什么很多站点第二次打开速度会很快？

应用层定义应用程序网络进程间的通信规则。HTTP协议是一种允许浏览器向服务器获取资源的协议。

浏览器发起HTTP请求的过程：
1. 构建请求
2. 查找浏览器缓存
3. 准备IP地址和TCP端口，查找DNS缓存 -> 请求DNS服务器获取URL对应的IP，TCP默认80端口
4. 等待TCP队列，Chrome中同一个域名同时最多只能建立6个TCP链接
5. 建立TCP链接
6. 发送HTTP请求
    - 向服务端发送请求行（请求方法、请求URI和HTTP版本协议）
    - 向服务端发送请求头（操作系统信息、浏览器信息、Cookie等）

服务端处理HTTP请求的过程：
1. 返回请求
    - 返回响应行（协议版本、状态码）
    - 返回响应头（响应时间、返回的数据类型）
    - 返回响应体
2. 断开链接，如果响应头中返回`Connection:Keep-Alive`，TCP 连接在发送后将仍然保持打开状态，浏览器可以继续通过同一个TCP连接发送请求不必再建立连接
3. 处理重定向，处理状态码301响应头中返回`location`的情况

**为什么很多站点第二次打开速度会很快？**

DNS和页面资源被浏览器缓存。

**服务端是通过什么方式让浏览器缓存数据的？**

通过响应头中的`Expires`和`Cache-Control`字段设置是否缓存该资源。

`Expires`设置明确的过期时间，缺点是浏览器时间判断不一定是准确的实际时间；

```
Cache-Control:Max-age=2000
```

`Catche-Control`设置相对时间，以秒为单位，优先级大于`Expires`

如果本地缓存已过期或者`Cache-Control: no-cache`需要重新验证，浏览器发出请求，服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。验证机制有两种：
- 服务端返回`Last-Modified`，客户端带上`If-Modified-Since`：记录和比较资源的修改时间，存在的问题：1. 时间误差 2. 资源修改和时间修改可能不一致
- 服务端返回`ETag`，客户端带上`If-None-Match`：服务端通过哈希算法根据文件内容计算出哈希值，记录和比较资源的哈希值，`ETag`优先级大于`Last-Modified`

![](https://segmentfault.com/img/remote/1460000016745595?w=901&h=815)

**登录状态是如何保持的？**

服务器端返回`Set-Cookie`，客户端保存`Cookie`，在请求时请求头带上`Cookie`。服务器端接收到`Cookie`字段信息查询后台。在服务器端一般会用`Session`作为用户登录状态和基本信息的存储体，`Cookie`中带上`sessionId`进行通信。


## 从输入URL到页面展示，这中间发生了什么？

Chrome浏览器目前的架构中有浏览器进程、渲染进程、网络进程。

导航流程

1. 处理输入：浏览器进程读取地址栏的输入信息并判断。如果是搜索字段，和默认的搜索引擎地址合成新的URL；如果是合法的URL则根据规则加上协议合成为完整的URL。在此阶段浏览器进程还会询问渲染进程是否需要执行`beforeunload`事件，渲染进程执行完`beforeunload`事件再进行后续处理。UI上显示加载状态
2. URL请求：浏览器进程通知网络进程进行URL请求，网络进程查找缓存 -> 查找IP和TCP -> 等待TCP连接 -> 建立TCP连接 -> 发送请求 -> 接收响应 -> 根据数据响应类型决定如何处理响应内容。如果返回的状态码是301或302，则跳转到`location`指定的URL重新进行导航。
3. 准备渲染进程：通常情况下，打开新的页面都会使用单独的渲染进程；如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程。
4. 提交稳定：将网络进程接收到的数据交给渲染进程。
  - 浏览器进程接收到网络进程的响应头数据，向渲染进程发起“提交文档”消息
  - 渲染进程接收到消息后和网络进程建立“管道”
  - 数据接收完毕，渲染进程通知浏览器进程“文档确认提交”
  - 浏览器进程更新地址栏信息、前进后退信息、安全状态

渲染流程

1. 构建 DOM 树：HTML - HTML 解析器 - DOM 树
2. 样式计算：CSS文本 - 渲染引擎 - 节点的计算样式
   1. 渲染引擎将CSS文本转换为styleSheets结构数据，`document.styleSheets`
   2. 转换样式表中的属性值，使其标准化，譬如`2em`转换为`32px`
   3. 根据CSS继承和层叠规则，计算DOM节点的样式，Devtools的`computed`栏
3. 布局（Layout）：DOM + 计算样式 - 布局树（记录可见元素的几何坐标位置）
   1. DOM + ComputedStyle -> 布局树（只包含可见元素）
   2. 布局树 -> 计算每个元素的几何坐标位置 -> 布局树
4. 分层（Layer）：按一定的规则把节点组合生成图层树（表现层叠顺序）
   1. 拥有层叠上下文属性的元素会被提升为单独的一层。
   2. 需要剪裁（clip）的地方也会被创建为图层。
5. 绘制列表（Paint）：每个图层的绘制指令列表（绘制顺序和具体操作）
   - 把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，类似于使用`canvas`，查看绘制列表（Layers - document -> Show Paint Profiler）
6. 分块（tiles）：渲染进程中，主线程把绘制列表提交（commit）给合成线程，合成线程会将图层划分为图块
7. 栅格化（raster）操作
   - 渲染进程维护了一个栅格化的线程池，图块栅格化都是在线程池内执行的
   - 栅格化即将图块转换为位图（优先转换视口附近的图块），一般栅格化过程都会使用 GPU 来加速生成（快速栅格化），生成的位图被保存在 GPU 内存中。

8. DrawQuad：光栅化完毕，合成线程通过`DrawQuad`命令通知浏览器进程绘制页面内容，显示到屏幕上



### 重排

修改元素的几何位置属性，改变宽度、高度等

![](https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png)

### 重绘

更新元素绘制相关属性，如更改某些元素的背景颜色

![](https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png)

### 合成

更改一个既不要布局也不要绘制的属性，比如CSS transform，直接在非主线程上执行合成动画操作

![](https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png)



## 变量提升：JavaScript代码是按顺序执行的吗？

JavaScript代码经过编译阶段后再进入执行阶段。

一段JS代码经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。

执行上下文是JavaScript执行一段代码时的运行环境。

执行上下文中存在一个变量环境的对象（Viriable Environment），该对象中保存了变量的内容。

在编译阶段，JS引擎会一行一行分析代码，遇到变量、函数声明的时候，会在变量环境对象中存储属性。

在执行阶段，JS引擎会一行一行执行代码，遇到变量和函数调用时，会去变量环境对象中查找；遇到变量和函数赋值时，会去变量环境对象中更新数据。



## 调用栈：为什么JavaScript代码会出现栈溢出？

执行上下文

1. 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
2. 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
3. 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文

调用栈

用来管理函数调用关系的一种数据结构。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。反应函数调用关系。

调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。



## 块级作用域：var缺陷以及为什么要引入let和const？

作用域决定变量和函数的可访问范围，决定变量和函数的可见性和生命周期。

> ES6 之前是不支持块级作用域的，因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。

变量提升带来的问题：

1. 变量容易在不被察觉的情况下被覆盖掉
2. 本应销毁的变量没有被销毁

### JavaScript 是如何支持块级作用域的

块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现。

执行到块作用域时，块内`let`/`const`声明的变量会被存放在独立单元压入词法环境栈，当块执行完毕从词法环境中出栈。在块作用域内，`let`声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。

执行代码过程中访问变量或函数，先在词法环境中从栈顶到栈底查找，再到变量环境中查找。

![](https://static001.geekbang.org/resource/image/7e/fa/7e0f7bc362e0dea21d27dc5fb08d06fa.png)

## 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？

JavaScript 作用域链是由词法作用域（代码编译阶段决定）决定的，由代码的静态位置决定，与函数调用无关。

执行上下文的变量环境中，包含一个外部引用 —— outer，用来指向外部的执行上下文，从而形成作用域链。

在当前执行上下问的变量环境中没有找到目标变量，就会延作用域链继续查找。

### 闭包

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包（Closure(foo)）。内部函数的作用域链是Local–>Closure(foo)–>Global



### 闭包是怎么回收的

如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。



## this：从JavaScript执行上下文的视角讲清楚this

this 是和执行上下文绑定的。和作用域链机制几乎没有联系。

执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，

所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。

在全局执行上下文中，this的值是全局对象。

- 函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象；

- 当函数作为对象的方法调用时，函数中的 this 就是该对象；

- 在构造函数中，`this`指实例化对象，通过`new`关键字构造对象实际上相当于

  ```js
  var tempObj = {} 
  CreateObj.call(tempObj)
  return tempObj
  ```

- 可以使用`call`或者`bind`手动更改函数的`this`

- 嵌套函数中的 this 不会继承外层函数的 this 值。解决思路：

  - 第一种是把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。
  - 第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this。



## 栈空间和堆空间：数据是如何存储的？

JavaScript 是一种弱类型的、动态的语言。

JavaScript中有8种数据类型：Boolean, String, Number, BigInt, Symbol, Null, Undefined, Object

前面七种是原始类型，Object是引用类型。原始类型和引用类型在内存的存放方式不同。

原始类型存放在栈空间中；引用类型存放在堆空间中，栈中存放堆中的引用地址。

具体的说，如下图所示。变量环境中直接存放原始数据类型的变量值，存放引用数据类型在堆中的引用地址。

![](https://static001.geekbang.org/resource/image/22/bc/22100df5c75fb51037d7a929777c57bc.png)

栈空间不会太大，适合放置小数据；堆空间很大，可以动态分配内存。

### 从内存机制解释闭包

预扫描内部函数；把内部函数引用的外部变量保存到堆中。

### 深拷贝的实现



## 垃圾回收：垃圾数据是如何自动回收的？

垃圾数据回收分为手动回收和自动回收两种策略。 C/C++ 就是使用手动回收策略，何时分配内存、何时销毁内存都是由代码控制的。JavaScript使用的是自动回收策略，产生的垃圾数据是由垃圾回收器来释放的。

JavaScript中的数据存放在调用栈和堆中，垃圾回收对两个空间的数据有不同的处理机制。

在调用栈中，有一个记录当前执行状态的指针（称为 ESP），指向正在执行函数的执行上下文。当一个函数执行完毕，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。

堆中通过JavaScript中的垃圾回收器进行垃圾回收，垃圾回收策略建立在“代际假说”基础上。

“代际假说”有两个特点：

- 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
- 第二个是不死的对象，会活得更久。

Chrome的V8引擎把堆分为新生代和老生代两个区域。

新生代区域存放生存时间短占用空间较小的对象，通常只支持 1～8M 的容量，由副垃圾回收器负责垃圾回收。

老生代区域存放生存时间久或占用空间较大的对象，支持的容量远大于新生代区域，由主垃圾回收器负责回收。

垃圾回收器的主要执行流程：

1. 标记活动对象和非活动对象
2. 回收非活动对象占据的内存
3. 进行内存碎片整理（可选）

**副垃圾回收器**

Scavenge 算法，新生代区域等分为对象区域和空闲区域，新加入的对象放入对象区域，当对象区域快被写满时进行一次垃圾回收：

1. 标记阶段：标记对象区域中的活动对象
2. 回收阶段：把活动对象复制到空闲区域中，并有序排列
3. 对象空间和空闲空间进行反转，无限重复使用

为了执行效率，一般新生区的空间会被设置得比较小，为了解决空间存满的问题。V8引擎使用了对象晋升策略，经过两次垃圾回收仍旧存活的对象会被移入老生区。

**主垃圾回收器**

标记 - 清除（Mark-Sweep）算法：

1. 标记阶段：遍历调用栈，堆中未被引用的对象标记为可回收对象，引用到的对象标记为活动对象

2. 回收阶段：直接清除内存中的可回收对象

标记 - 整理（Mark-Compact）算法：

1. 标记阶段：遍历调用栈，堆中未被引用的对象标记为可回收对象，引用到的对象标记为活动对象

2. 整理阶段：将内存中的活动对象向一端移动，清理掉端空间以外的内存占用



JavaScript的垃圾回收也是在主线程上进行的，如果老生区的内存占用过大，垃圾回收的会长时间占用主线程，也就造成“全停顿”的现象。因此，V8引擎做了“增量标记算法”的优化以降低老生代垃圾回收造成的卡顿。

![](https://static001.geekbang.org/resource/image/de/e7/de117fc96ae425ed90366e9060aa14e7.png)



## 编译器和解释器：V8是如何执行一段JavaScript代码的？

V8引擎使用字节码+即时编译（JIT）技术

![](https://static001.geekbang.org/resource/image/1a/ae/1af282bdc4036096c03074da53eb84ae.png)

1. 源代码 经过词法分析和语法分析 转换为 AST，词法分析将源码拆解为`token`，再由语法分析把`token`数据按语法规则转为AST，如果存在语法错误在这一步会抛出语法错误，中断后续执行。

2. V8引擎生成执行上下文

3. 解释器Ignition根据AST生成字节码，字节码需要通过解释器转换为机器码才能执行。字节码所占的空间远小于机器码，可以减小系统的内存使用，以满足小内存设备支持。

   ![](https://static001.geekbang.org/resource/image/87/ff/87d1ab147d1dc4b78488e2443d58a3ff.png)

4. 解释器执行字节码时，会收集代码信息。如果发现有热点代码（HotSpot），编译器TurboFan将字节码转换为机器码保存起来，之后再执行到这段热点代码直接执行机器码。V8执行越久，被转换为机器码的代码就越多，执行效率越高。



