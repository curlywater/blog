# 《浏览器工作原理与实践》学习笔记

[《浏览器工作原理与实践》](https://time.geekbang.org/column/intro/100033601)学习笔记。

## Chrome 架构：仅仅打开了 1 个页面，为什么会有 4 个进程？

进程的特点：

- 独立内存空间，进程关闭后操作系统会回收进程所占用的内存
- 可多个拥有线程
  - 一个线程崩溃，进程也崩溃
  - 线程共享进程内存空间

单进程多线程浏览器时代：所有的功能模块都在一个进程里，特点：不稳定、不流畅、不安全。

- 一个页面崩溃导致整个浏览器崩溃
- 页面发生内存泄漏或者复杂运算，导致浏览器卡顿
- 页面脚本可以通过浏览器漏洞获取权限做一些恶意操作

多进程浏览器时代：

- Chrome 发布时的架构采取 1 个浏览器进程、多个渲染进程、多个插件进程
- Chrome 目前的架构是 1 个浏览器进程、1 个网络进程、1 个 GPU 进程、多个渲染进程、多个插件进程。
  - 优点：渲染进程间相互独立，页面不会互相影响，也不会影响到浏览器的运行。对渲染进程和插件进程沙箱隔离。
  - 缺陷：更高的资源占用（每个进程都包含公共基础结构的副本，比如JavaScript引擎），模块之间耦合性高、扩展性差。

未来面向服务架构时代：各种模块都被定义为服务，服务可以拆分组合到不同进程中。

打开一个页面，有4个进程： 1 个浏览器进程、1 个网络进程、1 个 GPU 进程、1个渲染进程。


## TCP 协议：如何保证页面文件能被完整送达浏览器？

![](https://static001.geekbang.org/resource/image/94/32/943ac29f7d5b45a8861b0cde5da99032.png)

- 互联网中数据通过数据包传输，数据包在传输过程中容易丢失或出错
- 网络层在数据包上加上IP头（IP头包括IP版本、源IP地址、目标IP地址、生存时间信息等），通过IP地址确保数据包传输到目标主机
- 传输层在数据包上加上UDP头（UDP头包括源端口号、目标主机端口号）通过端口号确保数据包传到正确的应用程序。UDP不提供错误包重发机制，也不验证包是否到达目的地。UDP不可靠但传的快，一般应用于游戏和视频中。
- 传输层在数据包上加上TCP头（TCP头包括源端口号、目标主机端口号、排序序列号）通过端口号确保数据包传到正确的应用程序，通过序列号保证数据包能组合完成。TCP提供重发机制，并且提供数据包排序机制把乱序的数据包重新组合成完整的原始数据，一般应用于要求数据传输可靠性的应用。
- TCP传输数据的过程：
  - 三次握手建立链接：“请求建立连接”，“已接收到请求，并同意建立连接”，“已接收到同意建立连接信号”
  - 传输数据接收端需要对每个数据包进行接收确认，发送端在规定时间内没有接收到确认信息则认为包丢失触发重发机制
  - 四次挥手断开链接：“请求释放连接”，“接收到客户端发送的释放连接请求”，“已经准备好释放连接了”，“接收到服务器准备好释放连接信号”

## HTTP请求流程：为什么很多站点第二次打开速度会很快？

应用层定义应用程序网络进程间的通信规则。HTTP协议是一种允许浏览器向服务器获取资源的协议。

浏览器发起HTTP请求的过程：
1. 构建请求
2. 查找浏览器缓存
3. 准备IP地址和TCP端口，查找DNS缓存 -> 请求DNS服务器获取URL对应的IP，TCP默认80端口
4. 等待TCP队列，Chrome中同一个域名同时最多只能建立6个TCP链接
5. 建立TCP链接
6. 发送HTTP请求
    - 向服务端发送请求行（请求方法、请求URI和HTTP版本协议）
    - 向服务端发送请求头（操作系统信息、浏览器信息、Cookie等）

服务端处理HTTP请求的过程：
1. 返回请求
    - 返回响应行（协议版本、状态码）
    - 返回响应头（响应时间、返回的数据类型）
    - 返回响应体
2. 断开链接，如果响应头中返回`Connection:Keep-Alive`，TCP 连接在发送后将仍然保持打开状态，浏览器可以继续通过同一个TCP连接发送请求不必再建立连接
3. 处理重定向，处理状态码301响应头中返回`location`的情况

**为什么很多站点第二次打开速度会很快？**

DNS和页面资源被浏览器缓存。

**服务端是通过什么方式让浏览器缓存数据的？**

1. 设置本地缓存，通过响应头中的`Expires`和`Cache-Control`字段告知浏览器资源的缓存有效时间。

`Expires`设置明确的过期时间，缺点是浏览器时间判断不一定是准确的实际时间；

```
Cache-Control:Max-age=2000
```

`Catche-Control`设置相对时间，以秒为单位，优先级大于`Expires`

2. 如果本地缓存已过期或者`Cache-Control: no-cache`，则需要重新验证。浏览器发出请求头，服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。验证机制有两种：

- 服务端响应头返回`Last-Modified`，客户端请求头带上`If-Modified-Since`：记录和比较资源的修改时间，存在的问题：1. 时间误差 2. 资源修改和时间修改可能不一致
- 服务端响应头返回`ETag`，客户端请求头带上`If-None-Match`：服务端通过哈希算法根据文件内容计算出哈希值，记录和比较资源的哈希值，`ETag`优先级大于`Last-Modified`

![](https://segmentfault.com/img/remote/1460000016745595?w=901&h=815)

**登录状态是如何保持的？**

服务器端返回`Set-Cookie`，客户端保存`Cookie`，在请求时请求头带上`Cookie`，服务器端接收到`Cookie`字段信息查询后台。

在服务器端一般会用`Session`作为用户登录状态和基本信息的存储体，`Cookie`中带上`sessionId`进行通信。


## 从输入URL到页面展示，这中间发生了什么？

输入URL到页面展示的过程可以分为导航和渲染两个阶段。

已Chrome浏览器为例，Chrome目前的架构中主要有浏览器进程、渲染进程、网络进程。

导航流程

1. 处理输入：浏览器进程读取地址栏的输入信息并判断。如果是搜索字段，和默认的搜索引擎地址合成新的URL；如果是合法的URL则根据规则加上协议合成为完整的URL。在此阶段浏览器进程还会询问渲染进程是否需要执行`beforeunload`事件，渲染进程执行完`beforeunload`事件再进行后续处理。浏览器UI上显示加载状态
2. URL请求：浏览器进程通知网络进程进行URL请求，网络进程查找缓存 -> 查找IP和TCP -> 等待TCP连接 -> 建立TCP连接 -> 发送请求 -> 接收响应 -> 根据数据响应类型决定如何处理响应内容。如果返回的状态码是301或302，则跳转到`location`指定的URL重新进行导航。
3. 准备渲染进程：通常情况下，打开新的页面都会使用单独的渲染进程；如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程。
4. 提交稳定：将网络进程接收到的数据交给渲染进程。
  - 浏览器进程接收到网络进程的响应头数据，向渲染进程发起“提交文档”消息
  - 渲染进程接收到消息后和网络进程建立“管道”
  - 数据接收完毕，渲染进程通知浏览器进程“确认提交”
  - 浏览器进程更新地址栏信息、前进后退信息、安全状态

渲染流程

1. 构建 DOM 树：HTML - HTML 解析器 - DOM 树

2. 样式计算：CSS文本 - 渲染引擎 - 节点的计算样式

   1. 渲染引擎将CSS文本转换为styleSheets结构数据，`document.styleSheets`
   2. 转换样式表中的属性值，使其标准化，譬如`2em`转换为`32px`
   3. 根据CSS继承和层叠规则，计算DOM节点的样式，Devtools的`computed`栏

3. 布局（Layout）：DOM + 计算样式 - 布局树（记录可见元素的几何坐标位置）

   1. DOM + ComputedStyle -> 布局树（只包含可见元素）
   2. 布局树 -> 计算每个元素的几何坐标位置 -> 布局树

4. 分层（Layer）：按一定的规则把节点组合生成图层树（表现层叠顺序）

   1. 拥有层叠上下文属性的元素会被提升为单独的一层。[生成层叠上下文的条件](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)

   2. 需要剪裁（clip）的地方也会被创建为图层。譬如容器有尺寸限制内容需要滚动显示的元素。

      ![](https://static001.geekbang.org/resource/image/7b/97/7b6ceaab23c6c6d8e5930864ff9d7097.png)

5. 绘制列表（Paint）：每个图层的绘制指令列表（记录绘制顺序和具体操作）

   - 把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，类似于使用`canvas`，查看绘制列表（Layers - document -> Show Paint Profiler）

6. 分块（tiles）：渲染进程中，主线程把绘制列表提交（commit）给合成线程。页面可能很大，但是显示在视口内的区域有限，无需将整个页面都生成位图。因此，合成线程会将图层划分为图块，优先生成视口区域附近的位图。

7. 光栅化（raster）操作

   - 渲染进程维护了一个栅格化的线程池，图块栅格化都是在线程池内执行的
   - 光栅化即将图块转换为位图（优先转换视口附近的图块），一般栅格化过程都会使用 GPU 来加速生成（快速栅格化），生成的位图被保存在 GPU 内存中。

8. DrawQuad：光栅化完毕，合成线程通过`DrawQuad`命令通知浏览器进程绘制内容，显示到屏幕上。



### 重排

修改元素的几何位置属性，改变宽度、高度等

![](https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png)

### 重绘

更新元素绘制相关属性，如更改某些元素的背景颜色

![](https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png)

### 合成

更改一个既不要布局也不要绘制的属性，比如CSS transform，直接在非主线程上执行合成动画操作

![](https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png)



## 变量提升：JavaScript代码是按顺序执行的吗？

JavaScript代码经过编译阶段后再进入执行阶段。

一段JS代码经过编译阶段，会生成两部分内容：执行上下文（Execution context）和可执行代码。

执行上下文是JavaScript执行一段代码时的运行环境。

执行上下文中存在一个变量环境的对象（Viriable Environment），该对象中保存了变量的内容。

在编译阶段，JS引擎会一行一行分析代码，遇到变量、函数声明的时候，会在变量环境对象中存储属性。也就是变量提升实现的基础。

在执行阶段，JS引擎会一行一行执行代码，遇到变量和函数调用时，会去变量环境对象中查找；遇到变量和函数赋值时，会去变量环境对象中更新数据。

![](https://static001.geekbang.org/resource/image/06/13/0655d18ec347a95dfbf843969a921a13.png)



## 调用栈：为什么JavaScript代码会出现栈溢出？

**执行上下文**

1. 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
2. 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
3. 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文

**调用栈**

用来管理函数调用关系的一种数据结构。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。反应函数调用关系。

调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。由于在递归中嵌套调用自身，递归深度超过10000时便会产生栈溢出。而尾调用优化在大多数浏览器中并不支持，因此可以使用改写为循环，或者使用定时器把一个任务拆分为多个小任务。



## 块级作用域：var缺陷以及为什么要引入let和const？

作用域决定变量和函数的可访问范围，决定变量和函数的可见性和生命周期。

> ES6 之前是不支持块级作用域的，因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。

变量提升带来的问题：

1. 变量容易在不被察觉的情况下被覆盖掉
2. 本应销毁的变量没有被销毁

### JavaScript 是如何支持块级作用域的

块级作用域是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现。

执行到块作用域时，块内`let`/`const`声明的变量会被存放在独立单元压入词法环境栈，当块执行完毕从词法环境中出栈。在执行到块作用域时会先进行分析，`let`声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。

执行代码过程中访问变量或函数，先在词法环境中从栈顶到栈底查找，再到变量环境中查找。

![](https://static001.geekbang.org/resource/image/7e/fa/7e0f7bc362e0dea21d27dc5fb08d06fa.png)

## 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？

JavaScript 作用域链是由词法作用域（代码编译阶段决定）决定的，词法作用域链即由代码所处的静态位置决定的链关系，与函数调用位置无关。

执行上下文的变量环境中，包含一个外部引用 —— outer，用来指向外部的执行上下文，从而形成作用域链。

在当前执行上下文的变量环境中没有找到目标变量，就会延作用域链继续查找。

扩展说明：在编译阶段，函数的`[[Environment]]`隐藏属性记录对外层词法作用域的引用，在生成执行上下文时`outer`通过`[[Environment]]`获取外部引用。

### 闭包

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量。

当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包（Closure(foo)）。内部函数的作用域链是Local–>Closure(foo)–>Global



### 闭包是怎么回收的

如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。



## this：从JavaScript执行上下文的视角讲清楚this

this 是和执行上下文绑定的。和作用域链机制几乎没有联系。

执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，

所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。

在全局执行上下文中，this的值是全局对象。

- 函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象；

- 当函数作为对象的方法调用时，函数中的 this 就是该对象；

- 在构造函数中，`this`指实例化对象，通过`new`关键字构造对象实际上相当于

  ```js
  var tempObj = {} 
  CreateObj.call(tempObj)
  return tempObj
  ```

- 可以使用`call`或者`apply`手动更改函数的`this`

- 函数绑定，`func.bind(context, arg1, arg2)`，函数绑定后返回一个类似函数的特殊对象，调用它时，它会把调用传递给`func`，并设置`this=context`，

- 嵌套函数中的 this 不会继承外层函数的 this 值。解决思路：

  - 第一种是把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。
  - 第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this。



## 栈空间和堆空间：数据是如何存储的？

JavaScript 是一种弱类型的、动态的语言。

JavaScript中有8种数据类型：Boolean, String, Number, BigInt, Symbol, Null, Undefined, Object

前面七种是原始类型，Object是引用类型。原始类型和引用类型在内存的存放方式不同。

原始类型存放在栈空间中；引用类型存放在堆空间中，栈中存放堆中的引用地址。

具体的说，如下图所示。变量环境中直接存放原始数据类型的变量值，存放引用数据类型在堆中的引用地址。

![](https://static001.geekbang.org/resource/image/22/bc/22100df5c75fb51037d7a929777c57bc.png)

栈空间不会太大，适合放置小数据；堆空间很大，可以动态分配内存。

### 从内存机制解释闭包

预扫描内部函数；把内部函数引用的外部变量保存到堆中。

### 深拷贝的实现

``` js
const mapTag = '[object Map]';
const setTag = '[object Set]';
const arrayTag = '[object Array]';
const objectTag = '[object Object]';
const argsTag = '[object Arguments]';

const boolTag = '[object Boolean]';
const dateTag = '[object Date]';
const numberTag = '[object Number]';
const stringTag = '[object String]';
const symbolTag = '[object Symbol]';
const errorTag = '[object Error]';
const regexpTag = '[object RegExp]';
const funcTag = '[object Function]';

const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];


function forEach(array, iteratee) {
    let index = -1;
    const length = array.length;
    while (++index < length) {
        iteratee(array[index], index);
    }
    return array;
}

function isObject(target) {
    const type = typeof target;
    return target !== null && (type === 'object' || type === 'function');
}

function getType(target) {
    return Object.prototype.toString.call(target);
}

function getInit(target) {
    const Ctor = target.constructor;
    return new Ctor();
}

function cloneSymbol(targe) {
    return Object(Symbol.prototype.valueOf.call(targe));
}

function cloneReg(targe) {
    const reFlags = /\w*$/;
    const result = new targe.constructor(targe.source, reFlags.exec(targe));
    result.lastIndex = targe.lastIndex;
    return result;
}

function cloneFunction(func) {
    const bodyReg = /(?<={)(.|\n)+(?=})/m;
    const paramReg = /(?<=\().+(?=\)\s+{)/;
    const funcString = func.toString();
    if (func.prototype) {
        const param = paramReg.exec(funcString);
        const body = bodyReg.exec(funcString);
        if (body) {
            if (param) {
                const paramArr = param[0].split(',');
                return new Function(...paramArr, body[0]);
            } else {
                return new Function(body[0]);
            }
        } else {
            return null;
        }
    } else {
        return eval(funcString);
    }
}

function cloneOtherType(targe, type) {
    const Ctor = targe.constructor;
    switch (type) {
        case boolTag:
        case numberTag:
        case stringTag:
        case errorTag:
        case dateTag:
            return new Ctor(targe);
        case regexpTag:
            return cloneReg(targe);
        case symbolTag:
            return cloneSymbol(targe);
        case funcTag:
            return cloneFunction(targe);
        default:
            return null;
    }
}

function clone(target, map = new WeakMap()) {

    // 克隆原始类型
    if (!isObject(target)) {
        return target;
    }

    // 初始化
    const type = getType(target);
    let cloneTarget;
    if (deepTag.includes(type)) {
        cloneTarget = getInit(target, type);
    } else {
        return cloneOtherType(target, type);
    }

    // 防止循环引用
    if (map.get(target)) {
        return map.get(target);
    }
    map.set(target, cloneTarget);

    // 克隆set
    if (type === setTag) {
        target.forEach(value => {
            cloneTarget.add(clone(value, map));
        });
        return cloneTarget;
    }

    // 克隆map
    if (type === mapTag) {
        target.forEach((value, key) => {
            cloneTarget.set(key, clone(value, map));
        });
        return cloneTarget;
    }

    // 克隆对象和数组
    const keys = type === arrayTag ? undefined : Object.keys(target);
    forEach(keys || target, (value, key) => {
        if (keys) {
            key = value;
        }
        cloneTarget[key] = clone(target[key], map);
    });

    return cloneTarget;
}

module.exports = {
    clone
};
```



## 垃圾回收：垃圾数据是如何自动回收的？

垃圾数据回收分为手动回收和自动回收两种策略。 C/C++ 就是使用手动回收策略，何时分配内存、何时销毁内存都是由代码控制的。JavaScript使用的是自动回收策略，产生的垃圾数据是由垃圾回收器来释放的。

JavaScript中的数据存放在调用栈和堆中，垃圾回收对两个空间的数据有不同的处理机制。

在调用栈中，有一个记录当前执行状态的指针（称为 ESP），指向正在执行函数的执行上下文。当一个函数执行完毕，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。

堆中通过JavaScript中的垃圾回收器进行垃圾回收，垃圾回收策略建立在“代际假说”基础上。

“代际假说”有两个特点：

- 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
- 第二个是不死的对象，会活得更久。

Chrome的V8引擎把堆分为新生代和老生代两个区域。

新生代区域存放生存时间短占用空间较小的对象，通常只支持 1～8M 的容量，由副垃圾回收器负责垃圾回收。

老生代区域存放生存时间久或占用空间较大的对象，支持的容量远大于新生代区域，由主垃圾回收器负责回收。

垃圾回收器的主要执行流程：

1. 标记活动对象和非活动对象
2. 回收非活动对象占据的内存
3. 进行内存碎片整理（可选）

**副垃圾回收器**

Scavenge 算法，新生代区域等分为对象区域和空闲区域，新加入的对象放入对象区域，当对象区域快被写满时进行一次垃圾回收：

1. 标记阶段：标记对象区域中的活动对象
2. 回收阶段：把活动对象复制到空闲区域中，并有序排列
3. 对象空间和空闲空间进行反转，无限重复使用

为了执行效率，一般新生区的空间会被设置得比较小，为了解决空间存满的问题。V8引擎使用了对象晋升策略，经过两次垃圾回收仍旧存活的对象会被移入老生区。

**主垃圾回收器**

标记 - 清除（Mark-Sweep）算法：

1. 标记阶段：遍历调用栈，堆中未被引用的对象标记为可回收对象，引用到的对象标记为活动对象

2. 回收阶段：直接清除内存中的可回收对象

标记 - 整理（Mark-Compact）算法：

1. 标记阶段：遍历调用栈，堆中未被引用的对象标记为可回收对象，引用到的对象标记为活动对象

2. 整理阶段：将内存中的活动对象向一端移动，清理掉端空间以外的内存占用



JavaScript的垃圾回收也是在主线程上进行的，如果老生区的内存占用过大，垃圾回收的会长时间占用主线程，也就造成“全停顿”的现象。因此，V8引擎做了“增量标记算法”的优化以降低老生代垃圾回收造成的卡顿。

![](https://static001.geekbang.org/resource/image/de/e7/de117fc96ae425ed90366e9060aa14e7.png)



## 编译器和解释器：V8是如何执行一段JavaScript代码的？

V8引擎使用字节码+即时编译（JIT）技术

![](https://static001.geekbang.org/resource/image/1a/ae/1af282bdc4036096c03074da53eb84ae.png)

1. 源代码 经过词法分析和语法分析 转换为 AST，词法分析将源码拆解为`token`，再由语法分析把`token`数据按语法规则转为AST，如果存在语法错误在这一步会抛出语法错误，中断后续执行。（[JavaScript AST可视化工具](https://resources.jointjs.com/demos/javascript-ast)）

2. V8引擎生成执行上下文

3. 解释器Ignition根据AST生成字节码，字节码需要通过解释器转换为机器码才能执行。字节码所占的空间远小于机器码，可以减小系统的内存使用，以满足小内存设备支持。

   ![](https://static001.geekbang.org/resource/image/87/ff/87d1ab147d1dc4b78488e2443d58a3ff.png)

4. 解释器执行字节码时，会收集代码信息。如果发现有热点代码（HotSpot），编译器TurboFan将字节码转换为机器码保存起来，之后再执行到这段热点代码直接执行机器码。V8执行越久，被转换为机器码的代码就越多，执行效率越高。



## 消息队列和事件循环：页面是怎么“活”起来的？

> 前面我们讲到了每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。

![](https://static001.geekbang.org/resource/image/e2/c6/e2582e980632fd2df5043f81a11461c6.png)

1. 主线程循环执行，每次循环从消息队列取出一个宏任务，宏任务里包含一个微任务列表。在当前宏任务执行完毕之前执行当前宏任务中的微任务。
2. 渲染进程中的其他线程通过向消息队列添加任务的方式，让主线程执行任务
3. 其他进程通过IPC把任务发送给IO线程，再又IO线程添加事件队列



## WebAPI：setTimeout是如何实现的？

渲染进程创建一个回调任务（包含定时器回调函数、当前时间、延迟时间），并把它放入延时队列。

一次事件循环中， 主线程从消息队列取出一个任务执行，完成后查看延时队列中有没有到期任务，有的话执行到期任务。（延时队列其实是一个hashmap结构）

这一机制决定了定时器的回调函数很可能不会准时进行，取决于同一次事件循环中消息队列任务的执行时间。

`clearTimeout`实际是根据`timerId`在延时队列中找到对应的回调任务并把它移出。

浏览器对定时器还有一些额外的设置，会产生一些使用陷阱：

1. 嵌套定时器的最小延时是4毫秒，这是因为定时器被执行5次之后，浏览器会认为函数被阻塞，因此把最小延时时间设置为4毫秒

   ![](https://static001.geekbang.org/resource/image/cb/cd/cbb3b2b1ac8eb4752a585df5445412cd.png)

2. 未激活页面的最小延时是1000毫秒，出于后台页面耗能的考虑，浏览器将后台页面内的定时器设置最小延时1000毫秒
3. 延迟执行时间最大值是2147483647毫秒（大约24.8天），浏览器内部是通过32bit存放延时值的
4. setTimeout的回调函数是以普通函数的形式调用的



### requestAnimationFrame

``` js
window.requestAnimationFrame(function (DOMHighResTimeStamp) {
 console.log(DOMHighResTimeStamp) // 开始去执行回调函数的时刻
})
```

在浏览器下次重绘之前执行回调函数，屏幕刷新频率一般是60fps，每秒钟60帧，每个刷新间隔执行一次回调函数。在页面未激活的情况下，`requestAnimationFrame()` 会被暂停调用以提升性能和电池寿命。





## WebAPI：XMLHttpRequest是怎么实现的？



![](https://static001.geekbang.org/resource/image/d3/77/d3d66afb1a103103e5c3f86c823efb77.png)

当循环系统执行一个任务的时候，会为这个任务维护一个系统调用栈（可以通过chrome://tracing/抓取，或者使用Performance获取核心调用信息），任务下包含一些子过程。譬如Parse HTML包括执行Script，解析Stylesheet这些子过程。

![](https://static001.geekbang.org/resource/image/29/c6/2914a052f4f249a52077692a22ee5cc6.png)

渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。

XMLHttpRequest使用步骤：

1. 创建xhr对象`let xhr = new XMLHttpRequest()`
2. 注册回调函数`ontimeout/onerror/onreadystatechange`
3. 配置基础请求信息`xhr.open("GET")/xhr.responseType = "text"/xhr.setRequestHeader`
4. 发起请求`xhr.send()`



## 宏任务和微任务：不是所有任务都是一个待遇

### 宏任务

在任务队列中的任务称为宏任务。

在WHATWG 规范中，事件循环机制包含多个任务队列，比如鼠标事件的队列、IO完成消息队列、渲染任务队列；并且这些任务队列都有优先级。在进行一次循环时，从任务队列中取出优先级最高的任务执行。

在浏览器的实现中，目前只有一个消息队列，和一个延迟执行队列。先执行消息队列中的队首任务，再执行延迟执行队列中的到期任务。

宏任务执行的间隔是由系统控制的，在宏任务执行间隙系统可以插入一些系统级的任务，无法人为干预系统级任务的执行时长。因此宏任务的时间间隔无法精确控制。

异步回调的实现有两种方法：

1. 把回调函数封装为一个宏任务——回调任务，添加到消息队列。`setTimeout`和`XMLHttpRequest`采用这种方式。
2. 把回调函数封装为微任务添加到当前宏任务的微任务队列中。当前宏任务执行完毕之前，执行微任务队列中的回调函数。`MutationObserver`和`Promise`采取这种方式。

### 微任务

微任务可以在实时性和效率之间做一个有效的权衡。

实时性：宏任务的时间间隔不可控，时间颗粒度大。

效率：微任务触发的频率和概率较大，如果每一次触发都响应容易增加任务耗时。

![](https://static001.geekbang.org/resource/image/83/88/839f468be3d683019c309e0acd8cd788.png)

![](https://static001.geekbang.org/resource/image/1d/92/1db319c879610816c0cfea22723fc492.png)

> 通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。WHATWG 把执行微任务的时间点称为检查点。当然除了在退出全局执行上下文式这个检查点之外，还有其他的检查点，不过不是太重要，这里就不做介绍了。



### 监听 DOM 变化方法演变

1. 事件轮询
2. Mutation Event同步回调
3. MutationObserver异步调用和减少触发次数



## Promise：使用Promise，告别回调函数

Promise 解决的是异步编码风格的问题。

嵌套调用的问题：通过延时注册回调函数、promise返回值穿透。

频繁的错误处理：错误冒泡

由于Promise延时注册回调函数，因此需要使用微任务推迟`resolve`和`reject`的执行。Promise在执行resolve或者reject时，触发微任务。

### Promise 中为什么要引入微任务？
为了解决传统异步编码回调嵌套过多，导致回调地狱的问题。Promise采取了延时注册回调函数的方式实现了链式回调。
因为回调函数的注册在执行函数运行之后，因此需要在resolve和reject执行时延缓回调函数执行。需要把回调函数的使用延缓到回调函数注册之后。
那么一种方式使用`setTimeout`，而由于消息队列里的宏任务的时间粒度比较大，执行效率不高，因此使用微任务取而代之。

### Promise 中是如何实现回调函数返回值穿透的？Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获异常的函数？

一个promise对象包含`state`,`value`,`queue`三个属性。

state和value对应三种状态：
- 未执行完毕：`pending/undefined`
- 成功（resolved）：`fulfilled/result`
- 失败（rejected）：`rejected/error`

对Promise构造函数进行模拟，实例化返回一个promise对象
``` js
'use strict';

function INTERNAL() {}

var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;

module.exports = Promise;

function Promise(resolver) {
  if (!isFunction(resolver)) {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.value = void 0;
  this.queue = [];
  if (resolver !== INTERNAL) {
    safelyResolveThen(this, resolver);
  }
}
```

调用`promise.then`和`promise.catch`会返回新的promise对象，并封装成QueueItem对象放入`promise.queue`。
QueueItem包括promise对象、callFulfilled方法、callRejected方法。链式调用时queue内形成了嵌套关系。

``` js
var Promise = require('appoint')
var promise = new Promise((resolve) => {
  setTimeout(() => {
    resolve('haha')
  }, 1000)
})
promise
  .then(() => {})
  .then(() => {})
  .then(() => {})
console.dir(promise, { depth: 10 })
```

最终生成的promise对象
``` js
Promise {
  state: 0,
  value: undefined,
  queue:
   [ QueueItem {
       promise:
        Promise {
          state: 0,
          value: undefined,
          queue:
           [ QueueItem {
               promise:
                Promise {
                  state: 0,
                  value: undefined,
                  queue:
                   [ QueueItem {
                       promise: Promise { state: 0, value: undefined, queue: [] },
                       callFulfilled: [Function],
                       callRejected: [Function] } ] },
               callFulfilled: [Function],
               callRejected: [Function] } ] },
       callFulfilled: [Function],
       callRejected: [Function] } ] }
```

当最外层promise状态改变时，遍历它的queue调用对应的回调函数(callFulfilled/callRejected)，设置子promise的`state`和`value`，遍历其queue调用对应的回调函数，如此循环。

``` js
// 在callFulfilled/callRejected中，unwrap即是将同步执行转换为异步执行
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  this.callFulfilled = function (value) {
    doResolve(this.promise, value);
  };
  this.callRejected = function (error) {
    doReject(this.promise, error);
  };
  if (isFunction(onFulfilled)) {
    this.callFulfilled = function (value) {
      unwrap(this.promise, onFulfilled, value);
    };
  }
  if (isFunction(onRejected)) {
    this.callRejected = function (error) {
      unwrap(this.promise, onRejected, error);
    };
  }
}
function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (error) {
      return doReject(promise, error);
    }
    if (returnValue === promise) {
      doReject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      doResolve(promise, returnValue);
    }
  });
}

function safelyResolveThen(self, resolver) {
  var called = false;
  try {
    // Promise的执行函数，以resolve和reject函数作为参数。
    resolver(function (value) {
        // called防止多次调用resolve()和reject()
      if (called) {
        return;
      }
      called = true;
      doResolve(self, value);
    }, function (error) {
      if (called) {
        return;
      }
      called = true;
      doReject(self, error);
    });
  } catch (error) {
    if (called) {
      return;
    }
    called = true;
    doReject(self, error);
  }
}

function doResolve(self, value) {
  try {
    // 如果resolve函数的参数是带`then`方法的对象，设置then方法的this是对象，解决this问题
    var then = getThen(value);
    if (then) {
      safelyResolveThen(self, then);
    } else {
      self.state = FULFILLED;
      self.value = value;
      self.queue.forEach(function (queueItem) {
        queueItem.callFulfilled(value);
      });
    }
    return self;
  } catch (error) {
    return doReject(self, error);
  }
}

function doReject(self, error) {
  self.state = REJECTED;
  self.value = error;
  self.queue.forEach(function (queueItem) {
    queueItem.callRejected(error);
  });
  return self;
}
```

**Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获异常的函数？** 

在Promise执行过程中一直有`try...catch`包裹，当catch到错误时便会遍历调用promise.queue的callRejected方法，设置子promise的state为`rejected`，遍历调用promise.queue的callRejected方法，以此循环。

**Promise 中是如何实现回调函数返回值穿透的？**

在`Promise.prototype.then`中，如果传入的参数不是函数则直接返回promise对象本身。不然则生成一个内部promise对象返回，并且封装QueueItem并添加到父promise队列中。当父promise状态改变，遍历调用队列中promise对象对应的回调函数。

``` js
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (!isFunction(onFulfilled) && this.state === FULFILLED ||
    !isFunction(onRejected) && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.value);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }
  return promise;
};

Promise.prototype.catch = function (onRejected) {
  return this.then(null, onRejected);
};
```

## async/await：使用同步的方式去写异步代码

ES7推出async/await，也是一种编程风格，允许使用同步的方式实现异步编程。

async/await背后的技术是Promise和生成器，底层上来说是微任务和协程的结合使用。

生成器函数是一个可暂停执行，可恢复执行的函数。

生成器函数暂停、恢复依托的是协程。一个线程上可以存在多个协程，但是同时只能启动一个协程，在协程中可以启动另一个协程。在A协程中启动B协程，其实是A 协程将主线程的控制权交给 B 协程，A协程暂停执行B协程恢复执行。JavaScript引擎在A协程暂停时会保存A协程当前的调用栈信息，并恢复B协程的调用栈信息。

``` js

function* genDemo() {
    console.log("开始执行第一段")
    yield 'generator 2'

    console.log("开始执行第二段")
    yield 'generator 2'

    console.log("开始执行第三段")
    yield 'generator 2'

    console.log("执行结束")
    return 'generator 2'
}

console.log('main 0')
let gen = genDemo()
console.log(gen.next().value)
console.log('main 1')
console.log(gen.next().value)
console.log('main 2')
console.log(gen.next().value)
console.log('main 3')
console.log(gen.next().value)
console.log('main 4')
```

1. 通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，gen 协程并没有立即执行。
2. 要让 gen 协程执行，需要通过调用 gen.next。
3. 当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程。
4. 如果协程在执行期间，遇到了 return 关键字，那么 JavaScript 引擎会结束当前协程，并将 return 后面的内容返回给父协程。

使用Promise和生成器实现同步方式编写异步代码

``` js

//foo函数：同步方式编写
function* foo() {
    let response1 = yield fetch('https://www.geekbang.org')
    console.log('response1')
    console.log(response1)
    let response2 = yield fetch('https://www.geekbang.org/test')
    console.log('response2')
    console.log(response2)
}

//执行foo函数的代码
let gen = foo()
function getGenPromise(gen) {
    return gen.next().value
}
getGenPromise(gen).then((response) => {
    console.log('response1')
    console.log(response)
    return getGenPromise(gen)
}).then((response) => {
    console.log('response2')
    console.log(response)
})

// 上述代码可以使用执行器实现
co(foo())
```



async/await的执行过程

``` js
async function foo() {
    console.log(1)
    let a = await 100
    console.log(a)
    console.log(2)
}
console.log(0) 
foo()
console.log(3)
```

`async`函数是一个异步执行并隐式返回Promise的函数。上述代码的执行过程可以描述为：

1. 创建foo协程并执行

2. 当执行到`await`语句时，JavaScript引擎会创建一个Promise对象`Promise.resolve(100)`，在执行到`resolve`时创建一个任务提交给微任务队列。

3. 同时，foo协程暂停控制权交还给父协程，将Promise对象返回给父协程。父协程调用promise.then将回调函数加入promise的子队列，等待激活。

   ``` js
   promise_.then((value)=>{
      //回调函数被激活后
     //将主线程控制权交给foo协程，并将vaule值传给协程
   })
   ```

4. 父协程执行结束之前，进入微任务检查点，触发上述回调函数执行，将主线程控制权交给foo协程，并将vaule值传给协程。



## Chrome开发者工具：利用网络面板做性能分析

### 基础面板介绍

![](https://static001.geekbang.org/resource/image/c5/82/c5eb9603e79547ae3d815254e24d4782.png)

### 网络面板

下载信息概要

- DOMContentLoaded，已构建好DOM，说明HTML，JS，CSS文件已下载完毕
- Loaded，所有资源下载完毕（包括图片等）。

单个资源的时间线

![](https://static001.geekbang.org/resource/image/ba/af/ba91f06503bda4b4dc4a54901bd7a8af.png)

- 资源调度
  - Queueing：排队等待资源（等待原因资源优先级低、TCP最大数量限制、网络进程在处理磁盘空间分配）
- 发起连接
  - Stalled：延缓，一些原因可能导致连接发起被推迟
  - Proxy Negotiation：如果使用了代理服务器，表示代理服务器连接协商所用的时间
  - Initial connection：和服务器建立连接，包括TCP连接花费的时间
  - SSL：使用HTTPS协议，需要SSL握手时间协商一些加密信息
- 请求和响应
  - Request sent：从浏览器缓存的数据发送出去，不需要判断服务器是否收到
  - TTFB：接收到第一个响应字节等待的是时间
  - Content Download：从第一个响应字节到接收到所有内容花费的时间

优化时间线上耗时项

- Queueing过久
  - 升级到HTTP2，没有TCP连接最大数量限制
  - 域名分片，把资源分为多个域名放置
- TTFB过久
  - 服务器处理时间过久：尝试提高服务器速度，比如增加缓存
  - 网络原因：使用CDN缓存静态文件
  - 请求头上带入多余用户信息：发送请求时尽可能减少不必要的信息
- Content Download过久
  - 减小资源文件大小