---
title: 《浏览器工作原理与实践》学习笔记
permalink: /f2e/base/inside-browser
sidebar: auto
---
# 《浏览器工作原理与实践》学习笔记

[《浏览器工作原理与实践》](https://time.geekbang.org/column/intro/100033601)学习笔记。

## Chrome 架构：仅仅打开了 1 个页面，为什么会有 4 个进程？

进程的特点：

- 独立内存空间，进程关闭后操作系统会回收进程所占用的内存
- 可多个拥有线程
  - 一个线程崩溃，进程也崩溃
  - 线程共享进程内存空间

单进程多线程浏览器时代：所有的功能模块都在一个进程里，特点：不稳定、不流畅、不安全。

- 一个页面崩溃导致整个浏览器崩溃
- 页面发生内存泄漏或者复杂运算，导致浏览器卡顿
- 页面脚本可以通过浏览器漏洞获取权限做一些恶意操作

多进程浏览器时代：

- Chrome 发布时的架构采取 1 个浏览器进程、多个渲染进程、多个插件进程
- Chrome 目前的架构是 1 个浏览器进程、1 个网络进程、1 个 GPU 进程、多个渲染进程、多个插件进程。
  - 优点：渲染进程间相互独立，页面不会互相影响，也不会影响到浏览器的运行。对渲染进程和插件进程沙箱隔离。
  - 缺陷：更高的资源占用（每个进程都包含公共基础结构的副本，比如JavaScript引擎），模块之间耦合性高、扩展性差。

未来面向服务架构时代：各种模块都被定义为服务，服务可以拆分组合到不同进程中。

打开一个页面，有4个进程： 1 个浏览器进程、1 个网络进程、1 个 GPU 进程、1个渲染进程。


## TCP 协议：如何保证页面文件能被完整送达浏览器？

![](https://static001.geekbang.org/resource/image/94/32/943ac29f7d5b45a8861b0cde5da99032.png)

- 互联网中数据通过数据包传输，数据包在传输过程中容易丢失或出错
- 网络层在数据包上加上IP头（IP头包括IP版本、源IP地址、目标IP地址、生存时间信息等），通过IP地址确保数据包传输到目标主机
- 传输层通过端口号确保数据包传到正确的应用程序
  - UDP：在数据包上加上UDP头（UDP头包括源端口号、目标主机端口号）。UDP不提供错误包重发机制，也不验证包是否到达目的地。UDP不可靠但传的快，一般应用于游戏和视频中。
  - TCP：传输层在数据包上加上TCP头（TCP头包括源端口号、目标主机端口号、排序序列号），通过序列号保证数据包能组合完成。TCP提供重发机制，并且提供数据包排序机制把乱序的数据包重新组合成完整的原始数据，一般应用于要求数据传输可靠性的应用。
- TCP传输数据的过程：
  - 三次握手建立链接：“请求建立连接”，“已接收到请求，并同意建立连接”，“已接收到同意建立连接信号”
  - 传输数据接收端需要对每个数据包进行接收确认，发送端在规定时间内没有接收到确认信息则认为包丢失触发重发机制
  - 四次挥手断开链接：“请求释放连接”，“接收到客户端发送的释放连接请求”，“已经准备好释放连接了”，“接收到服务器准备好释放连接信号”

![](https://static001.geekbang.org/resource/image/b5/7d/b52b0d1a26ff2b8607c08e5c50ae687d.png)

## HTTP请求流程：为什么很多站点第二次打开速度会很快？

应用层定义应用程序网络进程间的通信规则。HTTP协议是一种允许浏览器向服务器获取资源的协议。

浏览器发起HTTP请求的过程：
1. 构建请求
2. 查找浏览器缓存
3. 准备IP地址和TCP端口，查找DNS缓存 -> 请求DNS服务器获取URL对应的IP，TCP默认80端口
4. 等待TCP队列，Chrome中同一个域名同时最多只能建立6个TCP链接
5. 建立TCP链接
6. 发送HTTP请求
    - 向服务端发送请求行（请求方法、请求URI和HTTP版本协议）
    - 向服务端发送请求头（操作系统信息、浏览器信息、Cookie等）
    - 向服务端发送请求体（可选）

服务端处理HTTP请求的过程：
1. 返回请求
    - 返回响应行（协议版本、状态码）
    - 返回响应头（响应时间、返回的数据类型）
    - 返回响应体（可选）
2. 断开链接，响应头中默认返回`Connection:Keep-Alive`，保持持久连接，TCP 连接在发送后将仍然保持打开状态。浏览器可以继续通过同一个TCP连接发送请求不必再建立连接。
3. 处理重定向，处理状态码301/302响应头中返回`location`的情况

**为什么很多站点第二次打开速度会很快？**

DNS和页面资源被浏览器缓存。

**服务端是通过什么方式让浏览器缓存数据的？**

1. 设置本地缓存，通过响应头中的`Expires`和`Cache-Control`字段告知浏览器资源的缓存有效时间。

`Expires`设置明确的过期时间，缺点是浏览器时间判断不一定是准确的实际时间；

`Catche-Control`设置相对时间，以秒为单位，优先级大于`Expires`。

2. 如果本地缓存已过期或者`Cache-Control: no-cache`，则需要重新验证。浏览器发出请求头，服务器端会验证请求中所描述的缓存是否过期，若未过期（注：状态码304），使用本地缓存副本。验证机制有两种：

- 服务端响应头返回`Last-Modified`，客户端请求头带上`If-Modified-Since`：记录和比较资源的修改时间，存在的问题：1. 时间误差 2. 资源修改和时间修改可能不一致。
- 服务端响应头返回`ETag`，客户端请求头带上`If-None-Match`：服务端通过哈希算法根据文件内容计算出哈希值，记录和比较资源的哈希值，`ETag`优先级大于`Last-Modified`。

![](https://segmentfault.com/img/remote/1460000016745595?w=901&h=815)

**登录状态是如何保持的？**

服务器端返回`Set-Cookie`，客户端保存`Cookie`，在请求时请求头带上`Cookie`，服务器端接收到`Cookie`字段信息查询后台。

在服务器端一般会用`Session`作为用户登录状态和基本信息的存储体，`Cookie`中带上`sessionId`进行通信。


## 从输入URL到页面展示，这中间发生了什么？

输入URL到页面展示的过程可以分为导航和渲染两个阶段。

以Chrome浏览器为例，Chrome目前的架构中主要有浏览器进程、渲染进程、网络进程。

导航流程

1. 处理输入：浏览器进程读取地址栏的输入信息并判断。如果是搜索字段，和默认的搜索引擎地址合成新的URL；如果是合法的URL则根据规则加上协议合成为完整的URL。在此阶段浏览器进程还会询问渲染进程是否需要执行`beforeunload`事件，渲染进程执行完`beforeunload`事件再进行后续处理。浏览器UI上显示加载状态
2. URL请求：浏览器进程通知网络进程进行URL请求，网络进程查找缓存 -> 查找IP和TCP -> 等待TCP连接 -> 建立TCP连接 -> 发送请求 -> 接收响应 -> 根据数据响应类型决定如何处理响应内容。如果返回的状态码是301或302，则跳转到`location`指定的URL重新进行导航。
3. 准备渲染进程：通常情况下，打开新的页面都会使用单独的渲染进程；如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程。
4. 提交数据：将网络进程接收到的数据交给渲染进程。
  - 浏览器进程接收到网络进程的响应头数据，向渲染进程发起“提交文档”消息
  - 渲染进程接收到消息后和网络进程建立传输数据的“管道”
  - 数据接收完毕，渲染进程通知浏览器进程“确认提交”
  - 浏览器进程更新标签页站点信息、地址栏信息、前进后退信息、站点安全状态

渲染流程

渲染进程包含主线程、合成线程、光栅化线程池这几个主要线程

1. 构建 DOM 树：HTML - HTML 解析器 - DOM 树

2. 样式计算：CSS文本 - 渲染引擎 - 节点的计算样式

   1. 渲染引擎将CSS文本转换为styleSheets结构数据，`document.styleSheets`
   2. 转换样式表中的属性值，使其标准化，譬如`2em`转换为`32px`
   3. 根据CSS继承和层叠规则，计算DOM节点的样式，Devtools的`computed`栏

3. 布局（Layout）：DOM + 计算样式 - 布局树（记录可见元素的几何坐标位置）

   1. DOM + ComputedStyle -> 布局树（只包含可见元素）
   2. 布局树 -> 计算每个元素的几何坐标位置 -> 布局树

4. 分层（Layer）：按一定的规则把节点组合生成图层树（表现层叠顺序）

   1. 拥有层叠上下文属性的元素会被提升为单独的一层。[生成层叠上下文的条件](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)。**P.S.存疑，实际测试并不是所有层叠上下文都会独立为图层，尚未解答**

   2. 需要剪裁（clip）的地方也会被创建为图层。譬如容器有尺寸限制内容需要滚动显示的元素。

      ![](https://static001.geekbang.org/resource/image/7b/97/7b6ceaab23c6c6d8e5930864ff9d7097.png)

5. 绘制列表（Paint）：每个图层的绘制指令列表（记录绘制顺序和具体操作）

   - 把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，类似于使用`canvas`，在Devtools中查看绘制列表的方式（Layers - 右键document -> Show Paint Profiler）

6. 分块（tiles）：渲染进程中，主线程把绘制列表提交（commit）给合成线程。页面可能很大，但是显示在视口内的区域有限，无需将整个页面都生成位图。因此，合成线程会将图层划分为图块，优先生成视口区域附近的位图。

7. 光栅化（raster）操作

   - 渲染进程维护了一个栅格化的线程池，图块栅格化都是在线程池内执行的
   - 光栅化即将图块转换为位图（优先转换视口附近的图块），一般光栅化过程都会使用 GPU 来生成位图，生成的位图被保存在 GPU 内存中。

8. DrawQuad：光栅化完毕，合成线程通过`DrawQuad`命令通知浏览器进程绘制内容，显示到屏幕上。



### 重排

修改元素的几何位置属性，改变宽度、高度等。会触发布局树构建以及之后的步骤。

![](https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png)

### 重绘

更新元素绘制相关属性，如更改某些元素的背景颜色。会省略布局阶段，触发绘制列表以及之后的步骤。

![](https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png)

### 合成

更改一个既不要布局也不要绘制的属性，比如CSS动效/透明度，直接在非主线程上执行合成动画操作

![](https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png)



## 变量提升：JavaScript代码是按顺序执行的吗？

JavaScript代码经过编译阶段后再进入执行阶段。

一段JS代码经过编译阶段，会生成两部分内容：执行上下文（Execution context）和可执行代码。

**执行上下文**

执行上下文是JavaScript执行一段代码时的运行环境。

1. 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
2. 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
3. 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文

执行上下文中存在一个变量环境的对象（Viriable Environment），该对象中保存了变量的内容。

在编译阶段，JS引擎会一行一行分析代码，遇到变量、函数声明的时候，会在变量环境对象中存储属性。也就是变量提升实现的基础。

在执行阶段，JS引擎会一行一行执行代码，遇到变量和函数调用时，会去变量环境对象中查找；遇到变量和函数赋值时，会去变量环境对象中更新数据。

![](https://static001.geekbang.org/resource/image/06/13/0655d18ec347a95dfbf843969a921a13.png)



## 调用栈：为什么JavaScript代码会出现栈溢出？

**调用栈**

用来管理函数调用关系的一种数据结构。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。反应函数调用关系。

调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。由于在递归中嵌套调用自身，递归深度超过100000时便会产生栈溢出。而尾调用优化在大多数浏览器中并不支持，因此可以使用改写为循环，或者使用定时器把一个任务拆分为多个任务。



## 块级作用域：var缺陷以及为什么要引入let和const？

作用域决定变量和函数的可访问范围，决定变量和函数的可见性和生命周期。

> ES6 之前是不支持块级作用域的，因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。

变量提升带来的问题：

1. 变量容易在不被察觉的情况下被覆盖掉
2. 本应销毁的变量没有被销毁

### JavaScript 是如何支持块级作用域的

块级作用域是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现。

执行到块作用域时，块内`let`/`const`声明的变量会被存放在独立单元压入词法环境栈，当块执行完毕从词法环境中出栈。在执行到块作用域时会先进行分析，`let`声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。

执行代码过程中访问变量或函数，先在词法环境中从栈顶到栈底查找，再到变量环境中查找。

![](https://static001.geekbang.org/resource/image/7e/fa/7e0f7bc362e0dea21d27dc5fb08d06fa.png)

## 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？

JavaScript 作用域链是由词法作用域（代码编译阶段决定）决定的，词法作用域链即由代码所处的静态位置决定的链关系，与函数调用位置无关。

执行上下文的变量环境中，包含一个外部引用 —— `outer`，用来指向外部的执行上下文，从而形成作用域链。

在当前执行上下文的变量环境中没有找到目标变量，就会延作用域链继续查找。

扩展说明：在编译阶段，函数的`[[Environment]]`隐藏属性记录对外层词法作用域的引用，在生成执行上下文时`outer`通过`[[Environment]]`获取外部引用。

### 闭包

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量。

当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包（Closure(foo)）。内部函数的作用域链是Local–>Closure(foo)–>Global



### 闭包是怎么回收的

如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。



## this：从JavaScript执行上下文的视角讲清楚this

`this` 是和执行上下文绑定的。和作用域链机制几乎没有联系。

`this` 的引用是在代码运行时计算出来的：

- 在全局执行上下文中，this 的值是全局对象。

- 函数被正常调用时，在严格模式下，this 值是 `undefined`，非严格模式下 this 指向的是全局对象；

- 当函数作为对象的方法调用时，函数中的 `this` 就是该对象；

- 在构造函数中，`this`指实例化对象

- 可以使用`call`或者`apply`手动更改函数的`this`

- 函数绑定，`func.bind(context, arg1, arg2)`，函数绑定后返回一个类似函数的特殊对象，调用它时，它会把调用传递给`func`，并设置`this=context`，

- 嵌套函数中的 `this` 不会继承外层函数的 this 值。解决思路：

  - 第一种是把 `this` 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。
  - 第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this。

扩展说明：

箭头函数本身没有`this`，导致以下三种现象：

- 根据外层（函数或者全局）作用域来决定 `this`
- 箭头函数不能作为构造函数使用
- 不能使用`call`, `apply`手动修改`this`

方法调用的内部原理：引用类型。

- 当以对象方法调用函数时：`object.method()`，点符号返回一个引用类型值 —— `(base, name, strict)`，`base`是对象，`name`是属性名，`strict`是`boolean`值严格模式下为`true`。
- 引用类型是一种特殊的“中间”内部类型，用于将信息从点符号 . 传递到调用括号 ()。
- 像赋值 `hi = user.hi` 等其他的操作，将引用类型作为一个整体丢弃，只获取 `user.hi`（一个函数）的值进行传递。因此，任何进一步的操作都会“失去” `this`。



## 栈空间和堆空间：数据是如何存储的？

JavaScript 是一种弱类型的、动态的语言。

JavaScript中有8种数据类型：Boolean, String, Number, BigInt, Symbol, Null, Undefined, Object

前面七种是原始类型，Object是引用类型。原始类型和引用类型在内存的存放方式不同。

原始类型存放在栈空间中；引用类型存放在堆空间中，栈中存放堆中的引用地址。

具体的说，如下图所示。变量环境中直接存放原始数据类型的变量值，存放引用数据类型在堆中的引用地址。

![](https://static001.geekbang.org/resource/image/22/bc/22100df5c75fb51037d7a929777c57bc.png)

栈空间不会太大，适合放置小数据；堆空间很大，可以动态分配内存。

### 从内存机制解释闭包

预扫描内部函数；把内部函数引用的外部变量保存到堆中。

![](https://static001.geekbang.org/resource/image/f9/db/f9dd29ff5371c247e10546393c904edb.png)

### 深拷贝的实现

``` js
const mapTag = '[object Map]';
const setTag = '[object Set]';
const arrayTag = '[object Array]';
const objectTag = '[object Object]';
const argsTag = '[object Arguments]';

const boolTag = '[object Boolean]';
const dateTag = '[object Date]';
const numberTag = '[object Number]';
const stringTag = '[object String]';
const symbolTag = '[object Symbol]';
const errorTag = '[object Error]';
const regexpTag = '[object RegExp]';
const funcTag = '[object Function]';

const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];


function forEach(array, iteratee) {
    let index = -1;
    const length = array.length;
    while (++index < length) {
        iteratee(array[index], index);
    }
    return array;
}

function isObject(target) {
    const type = typeof target;
    return target !== null && (type === 'object' || type === 'function');
}

function getType(target) {
    return Object.prototype.toString.call(target);
}

function getInit(target) {
    const Ctor = target.constructor;
    return new Ctor();
}

function cloneSymbol(targe) {
    return Object(Symbol.prototype.valueOf.call(targe));
}

function cloneReg(targe) {
    const reFlags = /\w*$/;
    const result = new targe.constructor(targe.source, reFlags.exec(targe));
    result.lastIndex = targe.lastIndex;
    return result;
}

function cloneFunction(func) {
    const bodyReg = /(?<={)(.|\n)+(?=})/m;
    const paramReg = /(?<=\().+(?=\)\s+{)/;
    const funcString = func.toString();
    if (func.prototype) {
        const param = paramReg.exec(funcString);
        const body = bodyReg.exec(funcString);
        if (body) {
            if (param) {
                const paramArr = param[0].split(',');
                return new Function(...paramArr, body[0]);
            } else {
                return new Function(body[0]);
            }
        } else {
            return null;
        }
    } else {
        return eval(funcString);
    }
}

function cloneOtherType(targe, type) {
    const Ctor = targe.constructor;
    switch (type) {
        case boolTag:
        case numberTag:
        case stringTag:
        case errorTag:
        case dateTag:
            return new Ctor(targe);
        case regexpTag:
            return cloneReg(targe);
        case symbolTag:
            return cloneSymbol(targe);
        case funcTag:
            return cloneFunction(targe);
        default:
            return null;
    }
}

function clone(target, map = new WeakMap()) {

    // 克隆原始类型
    if (!isObject(target)) {
        return target;
    }

    // 初始化
    const type = getType(target);
    let cloneTarget;
    if (deepTag.includes(type)) {
        cloneTarget = getInit(target, type);
    } else {
        return cloneOtherType(target, type);
    }

    // 防止循环引用
    if (map.get(target)) {
        return map.get(target);
    }
    map.set(target, cloneTarget);

    // 克隆set
    if (type === setTag) {
        target.forEach(value => {
            cloneTarget.add(clone(value, map));
        });
        return cloneTarget;
    }

    // 克隆map
    if (type === mapTag) {
        target.forEach((value, key) => {
            cloneTarget.set(key, clone(value, map));
        });
        return cloneTarget;
    }

    // 克隆对象和数组
    const keys = type === arrayTag ? undefined : Object.keys(target);
    forEach(keys || target, (value, key) => {
        if (keys) {
            key = value;
        }
        cloneTarget[key] = clone(target[key], map);
    });

    return cloneTarget;
}

module.exports = {
    clone
};
```



## 垃圾回收：垃圾数据是如何自动回收的？

垃圾数据回收分为手动回收和自动回收两种策略。 C/C++ 就是使用手动回收策略，何时分配内存、何时销毁内存都是由代码控制的。JavaScript使用的是自动回收策略，产生的垃圾数据是由垃圾回收器来释放的。

JavaScript中的数据存放在调用栈和堆中，垃圾回收对两个空间的数据有不同的处理机制。

在调用栈中，有一个记录当前执行状态的指针（称为 ESP），指向正在执行函数的执行上下文。当一个函数执行完毕，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。

堆中通过JavaScript中的垃圾回收器进行垃圾回收，垃圾回收策略建立在“代际假说”基础上。

“代际假说”有两个特点：

- 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
- 第二个是不死的对象，会活得更久。

Chrome的V8引擎把堆分为新生代和老生代两个区域。

新生代区域存放生存时间短占用空间较小的对象，通常只支持 1～8M 的容量，由副垃圾回收器负责垃圾回收。

老生代区域存放生存时间久或占用空间较大的对象，支持的容量远大于新生代区域，由主垃圾回收器负责回收。

垃圾回收器的主要执行流程：

1. 标记活动对象和非活动对象
2. 回收非活动对象占据的内存
3. 进行内存碎片整理（可选）

**副垃圾回收器**

Scavenge 算法，新生代区域等分为对象区域和空闲区域，新加入的对象放入对象区域，当对象区域快被写满时进行一次垃圾回收：

1. 标记阶段：标记对象区域中的活动对象
2. 回收阶段：把活动对象复制到空闲区域中，并有序排列
3. 对象空间和空闲空间进行反转，无限重复使用

为了执行效率，一般新生区的空间会被设置得比较小，为了解决空间存满的问题。V8引擎使用了对象晋升策略，经过两次垃圾回收仍旧存活的对象会被移入老生区。

**主垃圾回收器**

标记 - 清除（Mark-Sweep）算法：

1. 标记阶段：遍历调用栈，堆中未被引用的对象标记为可回收对象，引用到的对象标记为活动对象

2. 回收阶段：直接清除内存中的可回收对象

标记 - 整理（Mark-Compact）算法：

1. 标记阶段：遍历调用栈，堆中未被引用的对象标记为可回收对象，引用到的对象标记为活动对象

2. 整理阶段：将内存中的活动对象向一端移动，清理掉端空间以外的内存占用



JavaScript的垃圾回收也是在主线程上进行的，如果老生区的内存占用过大，垃圾回收的会长时间占用主线程，也就造成“全停顿”的现象。因此，V8引擎做了“增量标记算法”的优化以降低老生代垃圾回收造成的卡顿。

![](https://static001.geekbang.org/resource/image/de/e7/de117fc96ae425ed90366e9060aa14e7.png)



## 编译器和解释器：V8是如何执行一段JavaScript代码的？

V8引擎使用字节码+即时编译（JIT）技术

![](https://static001.geekbang.org/resource/image/1a/ae/1af282bdc4036096c03074da53eb84ae.png)

1. 源代码 经过词法分析和语法分析 转换为 AST，词法分析将源码拆解为`token`，再由语法分析把`token`数据按语法规则转为AST，如果存在语法错误在这一步会抛出语法错误，中断后续执行。（[JavaScript AST可视化工具](https://resources.jointjs.com/demos/javascript-ast)）

2. V8引擎生成执行上下文

3. 解释器Ignition根据AST生成字节码，字节码需要通过解释器转换为机器码才能执行。字节码所占的空间远小于机器码，可以减小系统的内存使用，以满足小内存设备支持。

   ![](https://static001.geekbang.org/resource/image/87/ff/87d1ab147d1dc4b78488e2443d58a3ff.png)

4. 解释器执行字节码时，会收集代码信息。如果发现有热点代码（HotSpot），编译器TurboFan将字节码转换为机器码保存起来，之后再执行到这段热点代码直接执行机器码。V8执行越久，被转换为机器码的代码就越多，执行效率越高。



## 消息队列和事件循环：页面是怎么“活”起来的？

> 前面我们讲到了每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。

![](https://static001.geekbang.org/resource/image/e2/c6/e2582e980632fd2df5043f81a11461c6.png)

1. 主线程循环执行，每次循环从消息队列取出一个宏任务，宏任务里包含一个微任务列表。在当前宏任务执行完毕之前，执行当前宏任务中的微任务。
2. 渲染进程中的其他线程通过向消息队列添加任务的方式，让主线程执行任务
3. 其他进程通过IPC把任务发送给IO线程，再又IO线程添加事件队列



## WebAPI：setTimeout是如何实现的？

渲染进程创建一个回调任务（包含定时器回调函数、当前时间、延迟时间），并把它放入延时队列。

一次事件循环中， 主线程从消息队列取出一个任务执行，完成后查看延时队列中有没有到期任务，有的话执行到期任务。（延时队列其实是一个hashmap结构）

这一机制决定了定时器的回调函数很可能不会准时进行，取决于同一次事件循环中消息队列任务的执行时间。

`clearTimeout`实际是根据`timerId`在延时队列中找到对应的回调任务并把它移出。

浏览器对定时器还有一些额外的设置，会产生一些使用陷阱：

1. 嵌套定时器的最小延时是4毫秒，这是因为定时器被执行5次之后，浏览器会认为函数被阻塞，然后把最小延时时间设置为4毫秒

   ![](https://static001.geekbang.org/resource/image/cb/cd/cbb3b2b1ac8eb4752a585df5445412cd.png)

2. 未激活页面的最小延时是1000毫秒，出于后台页面耗能的考虑，浏览器将后台页面内的定时器设置最小延时1000毫秒
3. 延迟执行时间最大值是2147483647毫秒（大约24.8天），浏览器内部是通过32bit存放延时值的
4. setTimeout的回调函数是以普通函数的形式调用的



### requestAnimationFrame

``` js
window.requestAnimationFrame(function (DOMHighResTimeStamp) {
 console.log(DOMHighResTimeStamp) // 开始去执行回调函数的时刻
})
```

在浏览器下次重绘之前执行回调函数，屏幕刷新频率一般是60fps，每秒钟60帧，每帧开始时执行回调函数。在页面未激活的情况下，`requestAnimationFrame()` 会被暂停调用以提升性能和电池寿命。



## WebAPI：XMLHttpRequest是怎么实现的？



![](https://static001.geekbang.org/resource/image/d3/77/d3d66afb1a103103e5c3f86c823efb77.png)

当循环系统执行一个任务的时候，会为这个任务维护一个系统调用栈（可以通过chrome://tracing/抓取，或者使用Performance获取核心调用信息），任务下包含一些子过程。譬如Parse HTML包括执行Script，解析Stylesheet这些子过程。

![](https://static001.geekbang.org/resource/image/29/c6/2914a052f4f249a52077692a22ee5cc6.png)

渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。

XMLHttpRequest使用步骤：

1. 创建xhr对象`let xhr = new XMLHttpRequest()`
2. 注册回调函数`ontimeout/onerror/onreadystatechange`
3. 配置基础请求信息`xhr.open("GET")/xhr.responseType="text"/xhr.setRequestHeader`
4. 发起请求`xhr.send()`



## 宏任务和微任务：不是所有任务都是一个待遇

### 宏任务

在任务队列中的任务称为宏任务。

在WHATWG 规范中，事件循环机制包含多个任务队列，比如鼠标事件的队列、IO完成消息队列、渲染任务队列；并且这些任务队列都有优先级。在进行一次循环时，从任务队列中取出优先级最高的任务执行。

在浏览器的实现中，目前只有一个消息队列，和一个延迟执行队列。先执行消息队列中的队首任务，再执行延迟执行队列中的到期任务。

宏任务执行的间隔是由系统控制的，在宏任务执行间隙系统可以插入一些系统级的任务，无法人为干预系统级任务的执行时长。因此宏任务的时间间隔无法精确控制。

异步回调的实现有两种方法：

1. 把回调函数封装为一个宏任务，添加到消息队列。`setTimeout`和`XMLHttpRequest`采用这种方式。
2. 把回调函数封装为微任务添加到当前宏任务的微任务队列中。当前宏任务执行完毕之前，执行微任务队列中的回调函数。`MutationObserver`和`Promise`采取这种方式。

### 微任务

微任务可以在实时性和效率之间做一个有效的权衡。

实时性：宏任务的时间间隔不可控，时间颗粒度大。微任务在当前宏任务主逻辑执行完毕准备退出前执行，相比之下更加实时；

效率：微任务触发的频率和概率较大，如果每一次触发都响应容易增加任务耗时。

![](https://static001.geekbang.org/resource/image/83/88/839f468be3d683019c309e0acd8cd788.png)

![](https://static001.geekbang.org/resource/image/1d/92/1db319c879610816c0cfea22723fc492.png)



### 监听 DOM 变化方法演变

1. 事件轮询
2. Mutation Event同步回调
3. MutationObserver异步调用和减少触发次数



## Promise：使用Promise，告别回调函数

Promise 解决的是异步编码风格的问题。

嵌套调用问题的解决方法：延时注册回调函数、promise返回值穿透。

频繁错误处理的解决方法：错误冒泡

### Promise 中为什么要引入微任务？
为了解决传统异步编码回调嵌套过多，导致回调地狱的问题。Promise 采取了延时注册回调函数的方式实现了链式回调。

因为回调函数的注册在执行函数运行之后，因此需要在`resolve`和`reject`执行时延缓回调函数执行。

需要把回调函数的使用延缓到回调函数注册之后。那么一种方式是使用`setTimeout`，而由于消息队列里的宏任务的时间粒度比较大，执行效率不高，因此使用微任务取而代之。

### Promise实现详解

一个`promise`对象包含`state`,`value`,`queue`三个属性。

`state`和`value`对应三种状态：

- 未执行完毕：`pending/undefined`
- 成功（resolved）：`fulfilled/result`
- 失败（rejected）：`rejected/error`

下列代码对Promise 构造函数进行模拟，实例化返回一个`promise`对象
``` js
'use strict';

function INTERNAL() {}

var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;

module.exports = Promise;

function Promise(resolver) {
  if (!isFunction(resolver)) {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.value = void 0;
  this.queue = [];
  if (resolver !== INTERNAL) {
    safelyResolveThen(this, resolver);
  }
}
```

调用`promise.then`和`promise.catch`会返回新的`promise`对象，并封装成`QueueItem`对象放入`promise.queue`。
`QueueItem`包括`promise`对象、`callFulfilled`方法、`callRejected`方法。链式调用时`queue`内形成了嵌套关系。如下例所示：

``` js
var Promise = require('appoint')
var promise = new Promise((resolve) => {
  setTimeout(() => {
    resolve('haha')
  }, 1000)
})
promise
  .then(() => {})
  .then(() => {})
  .then(() => {})
console.dir(promise, { depth: 10 })
```

最终生成的promise对象
``` js
Promise {
  state: 0,
  value: undefined,
  queue:
   [ QueueItem {
       promise:
        Promise {
          state: 0,
          value: undefined,
          queue:
           [ QueueItem {
               promise:
                Promise {
                  state: 0,
                  value: undefined,
                  queue:
                   [ QueueItem {
                       promise: Promise { state: 0, value: undefined, queue: [] },
                       callFulfilled: [Function],
                       callRejected: [Function] } ] },
               callFulfilled: [Function],
               callRejected: [Function] } ] },
       callFulfilled: [Function],
       callRejected: [Function] } ] }
```

当最外层`promise`状态改变时，遍历它的`queue`调用对应的回调函数(`callFulfilled`/`callRejected`)，设置子`promise`的`state`和`value`，遍历其`queue`调用对应的回调函数，如此循环。

``` js
// 在callFulfilled/callRejected中，unwrap即是将同步执行转换为异步执行
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  this.callFulfilled = function (value) {
    doResolve(this.promise, value);
  };
  this.callRejected = function (error) {
    doReject(this.promise, error);
  };
  if (isFunction(onFulfilled)) {
    this.callFulfilled = function (value) {
      unwrap(this.promise, onFulfilled, value);
    };
  }
  if (isFunction(onRejected)) {
    this.callRejected = function (error) {
      unwrap(this.promise, onRejected, error);
    };
  }
}
function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (error) {
      return doReject(promise, error);
    }
    if (returnValue === promise) {
      doReject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      doResolve(promise, returnValue);
    }
  });
}

function safelyResolveThen(self, resolver) {
  var called = false;
  try {
    // Promise的执行函数，以resolve和reject函数作为参数。
    resolver(function (value) {
        // called防止多次调用resolve()和reject()
      if (called) {
        return;
      }
      called = true;
      doResolve(self, value);
    }, function (error) {
      if (called) {
        return;
      }
      called = true;
      doReject(self, error);
    });
  } catch (error) {
    if (called) {
      return;
    }
    called = true;
    doReject(self, error);
  }
}

function doResolve(self, value) {
  try {
    // 如果resolve函数的参数是带`then`方法的对象，设置then方法的this是对象，解决this问题
    var then = getThen(value);
    if (then) {
      safelyResolveThen(self, then);
    } else {
      self.state = FULFILLED;
      self.value = value;
      self.queue.forEach(function (queueItem) {
        queueItem.callFulfilled(value);
      });
    }
    return self;
  } catch (error) {
    return doReject(self, error);
  }
}

function doReject(self, error) {
  self.state = REJECTED;
  self.value = error;
  self.queue.forEach(function (queueItem) {
    queueItem.callRejected(error);
  });
  return self;
}
```

**Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获异常的函数？** 

在Promise 执行过程中一直有`try...catch`包裹，当`catch`到错误时便会遍历调用`promise.queue`的`callRejected`方法，设置子`promise`的`state`为`rejected`，遍历调用`promise.queue`的`callRejected`方法，以此循环。

**Promise 中是如何实现回调函数返回值穿透的？**

在`Promise.prototype.then`中，如果传入的参数不是函数则直接返回`promise`对象本身。不然则生成一个内部`promise`对象返回，并且封装`QueueItem`添加到父`promise`队列中。当父`promise`状态改变，遍历调用队列中`promise`对象对应的回调函数。

``` js
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (!isFunction(onFulfilled) && this.state === FULFILLED ||
    !isFunction(onRejected) && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.value);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }
  return promise;
};

Promise.prototype.catch = function (onRejected) {
  return this.then(null, onRejected);
};
```

## async/await：使用同步的方式去写异步代码

ES7推出async/await，也是一种编程风格，允许使用同步的方式实现异步编程。

async/await背后的技术是Promise和生成器，底层上来说是微任务和协程的结合使用。

生成器函数是一个可暂停执行，可恢复执行的函数。

生成器函数暂停、恢复依托的是协程。一个线程上可以存在多个协程，但是同时只能启动一个协程，在协程中可以启动另一个协程。在A协程中启动B协程，其实是A 协程将主线程的控制权交给 B 协程，A协程暂停执行B协程恢复执行。JavaScript引擎在A协程暂停时会保存A协程当前的调用栈信息，并恢复B协程的调用栈信息。

``` js
function* genDemo() {
    console.log("开始执行第一段")
    yield 'generator 2'

    console.log("开始执行第二段")
    yield 'generator 2'

    console.log("开始执行第三段")
    yield 'generator 2'

    console.log("执行结束")
    return 'generator 2'
}

console.log('main 0')
let gen = genDemo()
console.log(gen.next().value)
console.log('main 1')
console.log(gen.next().value)
console.log('main 2')
console.log(gen.next().value)
console.log('main 3')
console.log(gen.next().value)
console.log('main 4')
```

1. 通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，gen 协程并没有立即执行。
2. 要让 gen 协程执行，需要通过调用 gen.next。
3. 当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程。
4. 如果协程在执行期间，遇到了 return 关键字，那么 JavaScript 引擎会结束当前协程，并将 return 后面的内容返回给父协程。

使用Promise和生成器实现同步方式编写异步代码

``` js
//foo函数：同步方式编写
function* foo() {
    let response1 = yield fetch('https://www.geekbang.org')
    console.log('response1')
    console.log(response1)
    let response2 = yield fetch('https://www.geekbang.org/test')
    console.log('response2')
    console.log(response2)
}

//执行foo函数的代码
let gen = foo()
function getGenPromise(gen) {
    return gen.next().value
}
getGenPromise(gen).then((response) => {
    console.log('response1')
    console.log(response)
    return getGenPromise(gen)
}).then((response) => {
    console.log('response2')
    console.log(response)
})

// 上述代码可以使用执行器实现
co(foo())
```



async/await的执行过程

``` js
async function foo() {
    console.log(1)
    let a = await 100
    console.log(a)
    console.log(2)
}
console.log(0) 
foo()
console.log(3)
```

`async`函数是一个异步执行并隐式返回Promise的函数。上述代码的执行过程可以描述为：

1. 创建`foo`协程并执行

2. 当执行到`await`语句时，JavaScript引擎会创建一个Promise对象`Promise.resolve(100)`，在执行到`resolve`时创建一个任务提交给微任务队列。

3. 同时，foo协程暂停控制权交还给父协程，将Promise对象返回给父协程。父协程调用`promise.then`将回调函数加入promise的子队列，等待激活。

   ``` js
   promise_.then((value)=>{
      //回调函数被激活后
     //将主线程控制权交给foo协程，并将vaule值传给协程
   })
   ```

4. 父协程执行结束之前，进入微任务检查点，触发上述回调函数执行。

5. 该微任务执行时，父协程将主线程控制权交给foo协程，并将vaule值传给foo协程。



## Chrome开发者工具：利用网络面板做性能分析

### 基础面板介绍

![](https://static001.geekbang.org/resource/image/c5/82/c5eb9603e79547ae3d815254e24d4782.png)

### 网络面板

下载信息概要

- DOMContentLoaded，已构建好DOM，说明HTML，JS，CSS文件已下载完毕。
- Loaded，所有资源下载完毕（包括图片等）。

单个资源的时间线

![](https://static001.geekbang.org/resource/image/ba/af/ba91f06503bda4b4dc4a54901bd7a8af.png)

- 资源调度
  - Queueing：排队等待资源（等待原因资源优先级低、TCP最大数量限制、网络进程在处理磁盘空间分配）
- 发起连接
  - Stalled：延缓，一些原因可能导致连接发起被推迟
  - Proxy Negotiation：如果使用了代理服务器，表示代理服务器连接协商所用的时间
  - Initial connection：和服务器建立连接，包括TCP连接花费的时间
  - SSL：使用HTTPS协议，需要SSL握手时间协商一些加密信息
- 请求和响应
  - Request sent：从浏览器缓存的数据发送出去，不需要判断服务器是否收到
  - TTFB：接收到第一个响应字节等待的是时间
  - Content Download：从第一个响应字节到接收到所有内容花费的时间

优化时间线上耗时项

- Queueing过久
  - 升级到HTTP2，没有TCP连接最大数量限制
  - 域名分片，把资源分为多个域名放置
- TTFB过久
  - 服务器处理时间过久：尝试提高服务器速度，比如增加缓存
  - 网络原因：使用CDN缓存静态文件
  - 请求头上带入多余用户信息：发送请求时尽可能减少不必要的信息
- Content Download过久
  - 减小资源文件大小

### Audits（Lighthouse）面板

使用Audits优化页面加载阶段的性能。在Chrome隐身模式下进行性能优化工作。

- 性能指标 (Metrics)

  - 首次绘制 (First Paint)：HTML因为网络原因导致加载时间过久；

  - 首次有效绘制 (First Meaningfull Paint)：计算规则复杂，不推荐使用；

  - 首屏时间 (Speed Index)：LCP，填满首屏所花费的时间，加载关键资源耗时过久或者JavaScript执行时间过久；

  - 首次 CPU 空闲时间 (First CPU Idle)：能对大部分用户输入做出响应的时间，优化和FMP、LCP一致；

  - 完全可交互时间 (Time to Interactive)：页面中所有元素都达到了可交互的时长，这时候页面的内容已经完全显示出来了，所有的 JavaScript 事件已经注册完成，页面能够对用户的交互做出快速响应；推迟执行和页面生成无关的JavaScript工作。

  - 最大估计输入延时 (Max Potential First Input Delay)，这个指标是估计你的 Web 页面在加载最繁忙的阶段， 窗口中响应用户输入所需的时间，为了改善该指标，我们可以使用 WebWorker 来执行一些计算，从而释放主线程。另一个有用的措施是重构 CSS 选择器，以确保它们执行较少的计算。

- 可优化项 (Opportunities)：Audits发现页面中可直接优化的部分
- 手动诊断 (Diagnostics)：可能存在性能问题的指标，需要手动排查
- 运行时设置 (Runtime Settings)

![](https://static001.geekbang.org/resource/image/70/99/7041b4d913a12d4d53041e8ed8b30499.png)



## Performance

概览面板

- 页面帧速（FPS）：出现红色块，表示红色块附近渲染出一帧所需时间过久
- CPU资源消耗（CPU）：CPU图像占用面积大，某个 JavaScript 占用太多的主线程时间
- 网络请求（NET）：网络请求概况
- 内存使用量（HEAP）：内存使用量一直在增加，就有可能是某种原因导致了内存泄漏
- 关键时间节点：FP、LCP、DOMContentLoaded、onload的事件节点（与性能面板中Timing对应）

性能面板

- Main：主线程任务执行过程，一个任务下包含多个过程。

  ![](https://static001.geekbang.org/resource/image/51/4b/5175c0405fa4d9d1a1e4fd261b92dc4b.png)

- Compositor：合成线程的任务执行记录

- Raster：光栅化线程池活动记录

- GPU：GPU进程任务执行记录

- Chrome_ChildIOThread：IO线程任务执行记录

- Network：页面中的每个网络请求所消耗的时长

- Timings：一些关键的时间节点在何时产生的数据信息

- Frames：记录渲染进程生成所有帧信息（渲染出每帧花费的时长，每帧的图层构造）

- Interactions：记录用户交互操作

## DOM树：JavaScript是如何影响DOM树构建的？

**什么是DOM**

DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。

**DOM树是如何解析的**

HTML 解析器是边加载边解析的，网络进程加载了多少数据，HTML 解析器便解析多少数据。在网络进程和渲染进程建立数据传输管道之后，渲染进程开始一边接收字节流一边将其解析为DOM。

- 第一个阶段：通过分词器将字节流转换为 Token：StartTagToken，文本Token，EndTag Token
- HTML 解析器维护了一个 Token 栈结构，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中，同时生成对应节点并把节点插入DOM树，具体流程如下：
  - HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，接着开始按顺序处理Token
  - 如果压入到栈中的是 StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。
  - 如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。
  - 如果分词器解析出来的是 EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。

**JavaScript 会阻塞DOM生成**

当解析器解析到`<script>`标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。脚本执行完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。

如果是引入JavaScript资源，则需要暂停 DOM 的解析，等待资源下载执行完成，通常下载非常耗时。因此需要进行一些优化：

Chrome增加了预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。

如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载

- async：加载完成后立即执行，无法保证资源执行顺序和执行时机
- defer：等待HTML解析完成之后执行

**样式文件会阻塞JavaScript执行**

JavaScript 代码中可能会存在操纵 CSSOM 的操作，而JavaScript引擎在解析JavaScript之前无法判断是否有CSSOM操作。

所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。

如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。

**安全性检查**

渲染引擎还有一个安全检查模块叫 XSSAuditor，是用来检测词法安全的。在分词器解析出来 Token 之后，它会检测这些模块是否安全，比如是否引用了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内容，XSSAuditor 会对该脚本或者下载任务进行拦截。



## 渲染流水线：CSS如何影响首次加载时的白屏时间？

![](https://static001.geekbang.org/resource/image/70/18/70a7ea0212ff35fc2be79f1d574ed518.png)

页面渲染必须等待CSS文件构建CSSOM（提供JavaScript操作接口、提供渲染引擎样式计算基础，`document.styleSheets`）

![](https://static001.geekbang.org/resource/image/76/1f/7641c75a80133e747aa2faae8f4c8d1f.png)

先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。

页面首次绘制的三个阶段：

1. 网络进程请求资源，渲染进程准备接收数据
2. 渲染进程开始接收数据，解析白屏阶段的瓶颈：下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。优化方式：
   1. 通过内联CSS、JavaScript，减少资源下载时间
   2. 利用打包工具减小JavaScript体积
   3. 使用异步加载防止JavaScript阻塞DOM解析（async/defer）
   4. 将CSS按场景分包，在特定场景下加载特定的CSS文件
3. 页面绘制



## 分层和合成机制：为什么CSS动画比JavaScript高效？

显示器有一个固定的刷新频率，一般是60HZ，系统每秒钟会从显卡的前缓冲区固定取60次图片

显卡负责生成图片保存在后缓冲区，一旦合成新的图片，就把前缓冲区和后缓冲区互换。要达到连贯的动画效果，需要在1秒内更新60张图片。

浏览器中通过渲染流程生成图片，生成一副图片称为一帧，帧率到达60Hz（60FPS）才能产生连贯的动画效果。



要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。

- 分层和合成：如果页面是未分层的一整张图片，那么一个细微的变动都需要把整张图片重新布局渲染一遍，当采用分层合成机制时，对于滚动和一些CSS动画效果只需要向上向下移动图层或对整个图层做几何变换、透明度变换、阴影，再合成，不需要重新计算布局树、图层树和绘制列表。
- 分块：即使只绘制优先级高的图块，也会受到纹理上传的影响，从计算机内存上传到GPU内存的操作速度比较慢。Chrome又做了一个优化，在首次合成图块的时候使用一个低分辨率的图片。等正常规格的图片生成完毕再替换掉低分辨率的内容。
- `will-change` 用来提前告诉渲染引擎，让它为该元素准备独立的层。在写 Web 应用的时候，你可能经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。如果使用`will-change`独立层，渲染引擎会通过合成线程直接去处理变换。但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加。

使用Devtools中的Layers/Performance/Memory面板观察下列代码在设置`will-change`和未设置`will-change`时的区别

``` html
<html>

<head>
    <title>观察will-change</title>
    <style>
        .box {
            will-change: transform, opacity;
            display: block;
            float: left;
            width: 40px;
            height: 40px;
            margin: 15px;
            padding: 10px;
            border: 1px solid rgb(136, 136, 136);
            background: rgb(187, 177, 37);
            border-radius: 30px;
            transition: border-radius 1s ease-out;
        }

        body {
            font-family: Arial;
        }
    </style>
</head>


<body>
    <div id="controls">
        <button id="start">start</button>
        <button id="stop">stop</button>
    </div>
    <div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
        <div class="box">旋转盒子</div>
    </div>
    <script>

        let boxes = document.querySelectorAll('.box');
        let boxes1 = document.querySelectorAll('.box1');
        let start = document.getElementById('start');
        let stop = document.getElementById('stop');
        let stop_flag = false


        start.addEventListener('click', function () {
            stop_flag = false
            requestAnimationFrame(render);
        })


        stop.addEventListener('click', function () {
            stop_flag = true
        })


        let rotate_ = 0
        let opacity_ = 0
        function render() {
            if (stop_flag)
                return 0
            rotate_ = rotate_ + 6
            if (opacity_ > 1)
                opacity_ = 0
            opacity_ = opacity_ + 0.01
            let command = 'rotate(' + rotate_ + 'deg)';
            for (let index = 0; index < boxes.length; index++) {
                boxes[index].style.transform = command
                boxes[index].style.opacity = opacity_
            }
            requestAnimationFrame(render);
        }
    </script>
</body>


</html>

```

## 页面性能：如何系统地优化页面？

- 加载阶段：
  - 减少关键资源的数量
    - 改成内联资源
    - 将资源变为非关键资源：JavaScript资源请求设置`async/defer`，CSS添加媒体取消阻止显现的标志
  - 减小关键资源的大小
    - 去除注释
    - 打包压缩
  - RTT的个数：一个RTT指一个数据包发送且确认接收的时长，一个数据包是14KB左右
    - 使用CDN降低RTT时长
- 交互阶段
  - 避免JavaScript一次执行霸占太久主线程
    - 将一次执行的函数分解为多个任务
    - 把一些和DOM无关的耗时计算放到WebWorkers中
  - 避免强制同步布局：一般浏览器会将操作和重渲染分为两个任务执行，强制同步布局指的是人为强制浏览器把操作和重渲染放在一个任务里，占据主线程，譬如在进行完DOM操作之后马上获取元素高度信息。
  - 避免布局抖动：布局抖动指的是在一次JavaScript执行中多次执行强制布局和抖动操作。
    - 尽量不要在修改 DOM 结构时再去查询一些相关值
  - 合理利用CSS合成动画
    - 小范围内对要使用动画特效的元素使用`will-change`，告诉渲染引擎该元素需要单独图层
  - 避免频繁的垃圾回收：如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。
    - 尽可能优化储存结构，尽可能避免小颗粒对象的产生。

## 虚拟DOM：虚拟DOM和实际的DOM有何不同？

虚拟DOM解决的问题：

1. 减少 JavaScript 对 DOM 的操作，避免频繁操作导致DOM反复重排、重绘、合成。

2. 避免对DOM操作不当，触发触发强制同步布局和布局抖动

虚拟DOM概念：

1. 初始化一个虚拟DOM树，创建出DOM树；数据改变创建一颗新的虚拟DOM树，比较得出变化点，一次更新到DOM树上。

2. 虚拟DOM比较复杂时，比较过程可能会占据主线程过久。Fiber reconciler代替Stack reconciler，比较过程分片执行，让出主线程。Fiber又名协程。



## 渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？

 PWA，它是由很多技术组成的一个理念，其核心思想是渐进式。

Web Worker存在于渲染进程之中，是与主线程同级的线程。

在目前的 Chrome 架构中，Service Worker 是运行在浏览器进程中的，因为浏览器进程生命周期是最长的，所以在浏览器的生命周期内，能够为所有的页面提供服务。

Service Worker脱离渲染进程之外，存活期跟随浏览器，使之能实现离线存储和接收消息推送的功能。同时，Service Worker采用HTTPS协议，保证网络通信的安全性。



## WebComponent：像搭积木一样构建Web应用

组件化：对内高内聚，对外低耦合

WebComponent 提供了对局部视图封装能力，可以让 DOM、CSSOM 运行在局部环境中，这样就使得局部的 CSS 和 DOM 不会影响到全局。

``` js

<!DOCTYPE html>
<html>


<body>
    <!--
            一：定义模板
            二：定义内部CSS样式
            三：定义JavaScript行为
    -->
    <template id="geekbang-t">
        <style>
            p {
                background-color: brown;
                color: cornsilk
            }


            div {
                width: 200px;
                background-color: bisque;
                border: 3px solid chocolate;
                border-radius: 10px;
            }
        </style>
        <div>
            <p>time.geekbang.org</p>
            <p>time1.geekbang.org</p>
        </div>
        <script>
            function foo() {
                console.log('inner log')
            }
        </script>
    </template>
    <script>
        class GeekBang extends HTMLElement {
            constructor() {
                super()
                //获取组件模板
                const content = document.querySelector('#geekbang-t').content
                //创建影子DOM节点
                const shadowDOM = this.attachShadow({ mode: 'open' })
                //将模板添加到影子DOM上
                shadowDOM.appendChild(content.cloneNode(true))
            }
        }
        customElements.define('geek-bang', GeekBang)
    </script>


    <geek-bang></geek-bang>
    <div>
        <p>time.geekbang.org</p>
        <p>time1.geekbang.org</p>
    </div>
    <geek-bang></geek-bang>
</body>


</html>
```

ShadowDOM 的作用是将模板中的内容与全局 DOM 和 CSS 进行隔离，使用 DOM 接口也是无法直接查询到影子 DOM 内部元素。但ShadowDOM中定义的JavaScript代码是全局性的，譬如定义的函数在外部也能访问。因为 JavaScript 语言本身已经可以很好地实现组件化了（类）。

![](https://static001.geekbang.org/resource/image/5b/22/5bce3d00c8139a7fde9cc90f9d803322.png)

每个影子 DOM 都有一个 shadow root 的根节点。

> 浏览器为了实现影子 DOM 的特性，在代码内部做了大量的条件判断，比如当通过 DOM 接口去查找元素时，渲染引擎会去判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是影子 DOM，那么就直接跳过 shadow-root 元素的查询操作。所以这样通过 DOM API 就无法直接查询到影子 DOM 的内部元素了。
>
> 另外，当生成布局树的时候，渲染引擎也会判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是，那么在影子 DOM 内部元素的节点选择 CSS 样式的时候，会直接使用影子 DOM 内部的 CSS 属性。所以这样最终渲染出来的效果就是影子 DOM 内部定义的样式。



## HTTP/1：HTTP性能优化

HTTP/0.9：支持传输HTML数据

HTTP/1.0：为了支持多类型数据，加入请求头/响应头。

- 信息支持：数据类型（多类型支持）、压缩方式（文件数据量增大）、语言版本（国际化）、编码类型（同种文件不同编码）
- 特性：状态码（明确服务器的处理结果）、Cache机制（减轻服务器压力）、用户代理（服务端需要收集用户信息）

HTTP/1.1：优化资源加载速度

- 改进持久链接（资源引用增多），浏览器为每个域名最多同时维护 6 个 TCP 持久连接
- 增加Host 字段，支持虚拟主机
- 引入 Chunk transfer 机制（数据分割为数据块，每个数据块发送时附上前一个数据块的长度，最后使用一个零长度数据块作为发送完毕的标志），解决动态生成内容无法确认何时停止接收的问题
- 引入Cookie机制和安全机制



## HTTP/2：如何提升网络速度？

HTTP/1.1存在的问题：无法高效利用带宽

1. TCP慢启动问题，在建立好链接发送数据阶段，TCP选择稳定提速。这是TCP协议减少网络拥塞的一种策略，在应用层无法避免
2. 多TCP连接竞争带宽，达到带宽上限时，各连接无论优先级高低统一降速
3. 队头阻塞问题，HTTP/1.1规定在一个TCP管道请求排队发送，当前请求未结束前，后面的请求都需等待

HTTP/2解决问题的思路：避免TCP慢启动和多连接，解决队头阻塞问题。

HTTP/2解决问题的方法：**多路复用**，浏览器和服务器之间通过一个TCP长连接通信，一个请求被分为多帧数据并标上ID传输，浏览器/服务器接收到数据之后将同一ID的数据包拼接为完整数据。

![](https://static001.geekbang.org/resource/image/0a/00/0a990f86ad9c19fd7d7620b2ef7ee900.jpg)

这一机制的实质是HTTP/2在协议栈中加了二进制分帧层，做数据拆分和拼接处理。

![](https://static001.geekbang.org/resource/image/86/6a/86cdf01a3af7f4f755d28917e58aae6a.png)

在这一机制上，HTTP/2还实现了其他特性：

1. 可设置请求优先级：因为无需保证数据包响应的连续性，服务器接受到优先级更高的请求可选择先处理。
2. 服务器推送相关资源：接收到HTML页面请求，服务器可以附带把相关的关键资源传输给浏览器
3. 头部压缩：HTTP/2 对请求头和响应头进行了压缩，多数请求都只有请求头。



## HTTP/3：甩掉TCP、TLS 的包袱，构建高效网络

HTTP/2在应用层对带宽利用率做了优化，而TCP层的瓶颈还未解决。

TCP的队头阻塞：TCP数据传输中，浏览器接收到服务端的确认接收信息才能发送下一个数据包，如果中间发生丢包，需要重传当前数据包，后续数据包都需要等待。我们知道在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。

TCP 建立连接的延时：握手过程需要花掉3~4个RTT，RTT的时耗和两主机距离相关。

TCP 协议僵化：互联网中间设备僵化，很难更新。



由于互联网中间设备僵化，因此很难在传输层增加新的协议，于是就有了基于 UDP 实现类似于 TCP 的多路数据流、传输可靠性等功能的协议 —— QUIC协议。

HTTP/3 基于 QUIC 协议

![](https://static001.geekbang.org/resource/image/0b/c6/0bae470bb49747b9a59f9f4bb496a9c6.png)

目前操作系统内核和互联网中间设备对UDP的优化远没有达到对TCP优化的程度，使用QUIC的丢包率还不理想。



## 同源策略：为什么XMLHttpRequest不能跨域请求资源？

> 在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全。

同源策略：会隔离不同源（协议、域名、端口其一不同）的 DOM、页面数据和网络通信

- DOM：DOM操作
- 页面数据：Cookie/本地数据读写操作
- 网络通信：通过 XMLHttpRequest 等方式发送数据

支持引用资源文件 -> 恶意脚本注入 -> XSS攻击 -> CSP内容安全策略（让服务器决定浏览器能加载哪些资源、能否执行内联JavaScript代码）

支持跨域发送数据 -> CORS（跨域资源共享）

支持DOM操作 -> 跨文档消息机制，通过`window.postMessage`通信



**CSP介绍**

Content-Security-Policy，内容安全策略。

CSP所具备的功能：

1. 限制加载其他域下的资源文件

2. 禁止向第三方域提交数据

3. 禁止执行内联脚本和未授权的脚本

4. 提供了上报机制

CSP的配置方法：通过服务器响应头设置Content-Security-Policy字段，或者使用`<meta>`元素配置策略。

``` bash
Content-Security-Policy: default-src 'self'; script-src https://example.com
```

CSP配置指令：

- [default-src](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src) 兜底
- [script-src](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/script-src) 限制script资源来源，是否允许eval()，是否允许内联脚本
- [style-src](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/style-src)限制样式表资源来源，是否允许使用内联样式
- [img-src](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/img-src)限制图片和favicon资源来源
- [font-src](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/font-src)限制`@font-face`加载字体的资源来源
- [connect-src](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/connect-src)限制允许通过脚本接口加载的资源来源，`Fetch/XHR/<a>/WebSocket`
- [child-src](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/child-src)：为 [web workers](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API) 和其他内嵌浏览器内容定义合法的源地址。
  - [frame-src](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/frame-src)限制内嵌上下文资源来源
  - [worker-src](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/worker-src)限制WebWorker，ServiceWorker脚本源

**CORS介绍**

笔记摘录于[阮一峰——《跨域资源共享 CORS 详解》](https://www.ruanyifeng.com/blog/2016/04/cors.html)。

Cross-origin resource sharing，跨域资源共享。CORS分为简单请求和非简单请求两种。

> 只要同时满足以下两大条件，就属于简单请求。
>
> （1) 请求方法是以下三种方法之一：
>
> - HEAD
> - GET
> - POST
>
> （2）HTTP的头信息不超出以下几种字段：
>
> - Accept
> - Accept-Language
> - Content-Language
> - Last-Event-ID
> - Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

简单请求

- 跨域许可
  - 浏览器发出跨域XHR/Fetch请求时，会往请求头自动加上Origin字段，表明当前请求来自于哪个源
  - 服务端获取请求头后确定Origin是否在允许访问范围内，如果是被允许的返回**Access-Control-Allow-Origin**字段
  - 浏览器接收到响应，如果响应头中不包含**Access-Control-Allow-Origin**抛出跨域拦截错误。

- Cookie请求许可

  - 默认跨域请求中不会带上Cookie，如果需要申请Cookie可用行
  - 浏览器在发送请求时，需要设置`xhr.withCredentials=true`
  - 服务端需要设置明确许可，在响应头中返回`Access-Control-Allow-Credentials: true`，页面是否可以获取到响应内容。

- 访问附加请求头信息

  > CORS请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。

非简单请求

> 在正式请求之前，增加一次HTTP查询请求，称为“预检”请求。
>
> 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。

预检请求用的方法是"OPTIONS"，请求头中附加

- Origin：请求源
- **Access-Control-Request-Method**：列出请求用到的方法
- **Access-Control-Request-Headers**：指定请求会发出的额外请求头字段，使用逗号分隔

接收到预检请求后，服务器给出响应头信息

- Access-Control-Allow-Origin：返回当前源
- **Access-Control-Allow-Methods**：返回服务器支持的所有跨域请求方法，使用逗号分隔
- **Access-Control-Allow-Headers**：返回服务器支持的所有自定义头字段
- **Access-Control-Allow-Credentials**：是否允许真正的请求可以使用credentials
- **Access-Control-Max-Age**：指定本次预检请求的有效期，单位为秒



## 跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？

XSS（Cross Site Scripting）：跨站脚本。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。

- 获取Cookie信息
- 监听键盘事件
- 操作DOM伪造登录表单
- 生成浮窗广告



**存储型XSS**

- 首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；
- 然后用户向网站请求包含了恶意 JavaScript 脚本的页面；
- 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。

**反射型 XSS 攻击**

- 恶意 JavaScript 脚本属于用户发送给网站请求中的一部分

- 随后网站又把恶意 JavaScript 脚本返回给用户页面执行

Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。

**基于 DOM 的 XSS 攻击**

通过网络劫持在页面传输过程中修改 HTML 页面的内容

**阻止XSS攻击的方法**

阻止恶意 JavaScript 脚本的注入和恶意消息的发送

1. 服务器对输入脚本进行过滤或转码
2. 充分利用 CSP
3. Cookie设置HttpOnly 属性



## CSRF攻击：陌生链接不要随便点

CSRF（Cross-site request forgery）：跨站请求伪造。引诱用户进入黑客的网站，利用用户的第三方站点登录状态，通过第三方站点做一些坏事。引入陷阱，利用服务器的漏洞和用户的登录状态来实施攻击。

阻止CSRF攻击的方法：

1. 充分利用好 Cookie 的 SameSite 属性
   1. Strict：完全禁止第三方 Cookie
   2. Lax：从第三方站点的链接打开和从第三方站点提交 Get 方式的表单会携带 Cookie
   3. None：在任何情况下都会发送 Cookie 数据
2. 服务器验证请求的来源站点：Referer和Origin
   1. Referer包含路径信息（请求时默认带上，但开发者可以通过设置Referrer-Policy选择不带上Referer）
   2. Origin不包含路径信息（XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法请求时带上Origin）
   3. 服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。
3. CSRF Token
   1. 服务器生成的字符串，然后将该字符串植入到返回的页面中
   2. 在浏览器端发起请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。



## 安全沙箱：页面和系统之间的隔离墙

单进程浏览器在系统安全方面的不足，如果浏览器存在漏洞，那么黑客就有机会通过页面对系统发起攻击。

多进程浏览器使用安全沙箱隔离渲染进程，渲染进程和渲染进程间隔离（站点隔离），渲染进程和浏览器内核间隔离（操作系统和渲染进程隔离）。

![](https://static001.geekbang.org/resource/image/b8/b1/b83693a1ace43f43f9cab242982de6b1.png)



安全沙箱最小的保护单位是进程，并且能限制进程对操作系统资源的访问和修改。由于渲染进程需要安全沙箱的保护，因此需要把在渲染进程内部涉及到和系统交互的功能都转移到浏览器内核中去实现。

![](https://static001.geekbang.org/resource/image/f8/1b/f8cc6394832ed238f18a01eff5726f1b.png)

## HTTPS：让数据传输更安全

![](https://static001.geekbang.org/resource/image/9e/cf/9e99f797de30a15a11b0e4b4c8f810cf.png)

安全层负责对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作。

第一版：对称加密（加密和解密使用相同的密钥）

![](https://static001.geekbang.org/resource/image/d8/3b/d86648267d5504c7813b2d692620503b.png)

加密套件指加密的方法，加密套件列表指浏览器支持的多种加密方法。

1. 浏览器发送支持的加密方法列表和一个随机数（client-random）给服务器
2. 服务器接收后，选择一个加密套件，生成一个随机数（service-random）
3. 浏览器和服务器同时根据client-random+service-random+加密方法计算出密钥，分辨返回确认信息

传输密钥计算要素的过程是明文的，黑客能盗取要素合成密钥。



第二版：非对称加密

非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。

![](https://static001.geekbang.org/resource/image/b2/50/b2b893921491c62b29aaddc1d4fa9550.png)

1. 浏览器发送加密套件列表
2. 服务器选择一个加密套件，生成一个公钥和一个私钥，私钥保留，公钥和加密套件返回给浏览器
3. 浏览器确认接收到加密要素信息，服务器确认已接收到浏览器的接收信息
4. 传输数据时，浏览器发送公钥加密数据
5. 服务器使用私钥解密数据

由于只有服务器握有私钥，因此浏览器发送的信息只有服务器可以解开。

存在的问题：非对称加密效率低，无法保证服务器发送给浏览器的数据安全



第三版：非称加密和非对称加密搭配使用

在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。

![](https://static001.geekbang.org/resource/image/d5/45/d5cd34dbf3636ebc0e809aa424c53845.png)

1. 浏览器使用公钥加密pre-master，服务器用私钥解密pre-master
2. 两端同时拥有client-random+service-random+pre-master，生成密钥



第四版：添加数字证书

黑客通过 DNS 劫持将极客时间官网的 IP 地址替换成了黑客的 IP 地址。还需要服务器向浏览器提供证明“我就是我”。

权威机构（CA）颁发证书（数字证书）

1. 服务器证明身份
2. 数字证书中包含公钥

![](https://static001.geekbang.org/resource/image/77/af/77c852ff2202b2b7bb3299a96a0f4aaf.png)

数字证书包含了：

1. 明文信息：组织的公钥、组织信息、CA 的信息、有效时间、证书序列号
2. 数字签名：Hash函数计算明文信息得到信息摘要，使用CA的私钥加密信息摘要得到密文

组织提交公钥和认证信息给CA，CA进过线上线下调查核实组织的真实合法性，再给组织颁发数字证书

![](https://static001.geekbang.org/resource/image/f5/a6/f569c80f8f4b25b3bf384037813cdca6.png)

服务器接收到浏览器请求后会返回数字证书（两个数字证书：组织域名的数字证书，CA机构的数字证书）给浏览器，浏览器需要验证数字证书的有效期、是否被吊销、是否是合法CA机构颁发的。

1. 验证证书是否是CA颁发的：浏览器使用Hash函数计算明文信息得到信息摘要A，利用对应CA的公钥（CA数字证书中包含公钥）解密数字签名得到信息摘要B，对比核实服务器的真实性。同时验证证书的域名信息和有效时间等信息。
2. 验证CA机构的合法性：数字证书链，不知名 CA -> 给这个 CA 颁发证书的 CA -> 上级 CA 的可靠性 -> 顶级CA的证书信息（WebTrust认证）。通常情况下，操作系统中会内置信任的顶级 CA 的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定非法。



## 浏览上下文组：如何计算Chrome中渲染进程的个数？

浏览上下文：一个标签页所包含的内容，诸如 window 对象，历史记录，滚动条位置等信息。

浏览上下文组：有相互连接关系的标签页（从一个页面中的链接打开，`window.open`）

Chrome浏览器把浏览上下文组中属于同一站点的标签分配到同一个渲染进程中。



如何阻止页面间产生连接关系：`rel="noopener"`

站点隔离：如果 A 标签页中的 iframe 和 A 标签页属于同一站点，那么该 iframe 和 A 标签页会共用同一个渲染进程，如果不是，则该 iframe 会使用单独的渲染进程。

![](https://static001.geekbang.org/resource/image/a1/0e/a13f917f227e85102998b3bfe38b4e0e.jpg)

**Chrome 为什么使用同一站点划分渲染进程，而不是使用同源策略来划分渲染进程？**

同一站点的安全性有保障，资源复用的优势。



## 任务调度：有了setTimeOut，为什么还要使用rAF？

**动态任务调度策略**

![](https://static001.geekbang.org/resource/image/3c/f5/3cc95247daae7f90f0dced017d349af5.png)

缓解“任务饿死问题”（一直有高优先级任务插入，先加入的低优先级任务得不到处理），每个队列设置了执行权重，如果连续执行了一定个数的高优先级的任务，那么中间会执行一次低优先级的任务。

**VSync时钟同步周期和页面生成周期**

![](https://static001.geekbang.org/resource/image/06/08/06206ed4846e9531351a0cb7d1db6208.png)

显示器在绘制完一帧画面后会发出一个垂直同步信号（VSync）给GPU，GPU将VSync信号同步给浏览器进程，浏览器进程同步给对应的渲染进程。

渲染进程在两个VSync之间的时间段内，完成一帧画面的合成最终提交到GPU后缓冲区。

在合成操作完成到下一个VSync到达之前的空闲时间，浏览器可以执行一些不那么紧急的任务，比如 V8 的垃圾回收，或者通过 window.requestIdleCallback() 设置的回调任务等。

rAF的回调任务会在每一帧的开始执行（在接收到VSync开始准备下一帧的时候）。

