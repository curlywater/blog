---
title: 复杂度计算
permalink: /algo/complexity
---

# 复杂度计算

## 大O复杂度表示法

不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。

``` cpp
 int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
```

假设每行代码执行的时间都是unit_time，上面这段代码的执行时间 $T(n) = (2n^2+2n+3) * unit\_time$

提取 $f(n) = 2n^2+2n+3$，代表每行代码的执行次数总和

可推导出下列关系：$T(n) = O(f(n))$

表示代码总执行时间 $T(n)$  与 每行代码的执行次数 $n$ 成正比。


## 时间复杂度

代码执行时间随数据规模增长的变化趋势。忽略常量和低阶量级。

### 常见时间复杂度

**非多项式时间复杂度**

$O(2^n)$ 和 $O(n!)$

当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加

**多项式时间复杂度**

> 对数之间是可以互相转换的，$log_3 n$ 就等于 $log_3 2 * log_2 n$，所以 $O(log_3 n) = O(C * log_2 n)$，其中 $C=log_3 2$ 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 $O(Cf(n)) = O(f(n))$。所以，$O(log_2 n)$ 就等于 $O(log_3 n)$。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 $O(log n)$。

低阶到高阶：$O(1)$、$O(log n)$、$O(n)$、$O(nlogn)$、$O(n^2)$

![](https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg)


### 最好/最坏/平均/均摊时间复杂度

最好时间复杂度：最理想情况下，执行代码的时间复杂度

最坏时间复杂度：最糟糕的情况下，执行代码的时间复杂度

平均时间复杂度：最好、最坏分布极端的情况下，计算加权平均值

均摊时间复杂度：最好、最坏复杂度按一定规律分布循环，把最坏情况下的时间分摊到最好情况下，最终结果一般趋向于最好时间复杂度。

## 空间复杂度

算法的存储空间与数据规模之间的增长关系

``` cpp
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

上述代码的空间复杂度是$O(n)$