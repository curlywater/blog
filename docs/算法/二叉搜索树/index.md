---
title: 二叉搜索树
permalink: /algo/binary-search-tree
---

# 二叉搜索树

## 什么是二叉搜索树

一种动态数据结构，支持高效快速的查找、插入、删除操作。

二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。

![](https://static001.geekbang.org/resource/image/f3/ae/f3bb11b6d4a18f95aa19e11f22b99bae.jpg)


## 操作实现

**查找**
- 等于根节点，返回
- 小于根节点，查找左子树
- 大于根节点，查找右子树


**插入**
- 大于根节点
    - 根节点右子树为空，插入到右子节点
    - 不为空，遍历右子树
- 小于根节点
    - 根节点左子树为空，插入到左子节点
    - 不为空，遍历左子树

**删除**
- 无子节点，直接删除
- 有一个子节点，子节点替代
- 有两个子节点，找到右子树的最小节点替代或者左子树的最大节点替代。

**输出有序序列**

中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效


### 算法框架

递归
```js
function BST(TreeNode root, int target) {
    if (root.val == target)
    // 找到目标，做点什么
    if (root.val < target) 
    BST(root.right, target);
    if (root.val > target)
    BST(root.left, target);
}
```


迭代
``` js
function BST(root, target) {
    let node = root;
	while(node) {
		if (node.val == target) {
            // 找到目标，做点什么
		}
		if (node.val < target) {
			node = node.right;
		}
		if (node.val > target) {
			node = node.left;
		}
	}
}
```

### 如何解决存在相同值的情况

方法一：每个节点存储多个值相同的数据

方法二：每个节点还是存储一个数据，将大于等于的节点放置在右子树，查找、插入、删除操作需要遍历右子树直到根节点


## 二叉平衡查找树

二叉搜索树的左右子树可能极不平衡，甚至退化至链表，时间复杂度达到O(n)

在及其及其平衡的平衡的情况下，构成完全二叉树，插入、删除、查找的时间复杂度是O(logn)

而“平衡二叉查找树”则是一种让左右两树高度近似相等的数据结构。努力使树平衡，从而使时间复杂度接近O(logn)

> 平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。

极度严格的平衡二叉树AVL树要求树中任意一个节点的左右子树的高度相差不能大于 1，时间复杂度严格等于log2n。

![](https://static001.geekbang.org/resource/image/dd/9b/dd9f5a4525f5029a8339c89ad1c8159b.jpg)


红黑树（R-B Tree）一种不严格的平衡二叉查找树，红黑树的高度近似 log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。


> 在动态操作后维持AVL树需要更多开销。对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。
> 红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。所以，红黑树的插入、删除、查找各种操作性能都比较稳定。
> 对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。

### 红黑树

红黑树的特点：
1. 根节点是黑色的；
2. 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
3. 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
4. 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

