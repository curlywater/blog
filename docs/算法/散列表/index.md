---
title: 散列表
permalink: /algo/hashtable
---

# 散列表


## 散列表

键key -> 散列函数hash(key) -> 散列值hash code

散列表：利用数组通过下标高效随机访问的特性。散列值对应数组下标，数组中存放信息。

散列函数设计的三点要求：

- 散列函数计算得到的散列值是一个非负整数；
- 如果 key1 = key2，那 hash(key1) == hash(key2)；
- 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。（散列函数无法完全避免散列冲突）

## 散列冲突解决方法

**开放寻址法（open addressing）**

出现了散列冲突，我们就重新探测一个空闲位置，将其插入。
常用探测方法：
- 线性探测：在循环散列表中，以步长为1向下寻址，如果定位到空闲空间，认为匹配失败
- 二次探测：步长为1，4，9，16...
- 双重散列：多个散列函数

**链表法（chaining）**

![](https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg)



## 如何设计散列函数？


- 散列函数的计算不能太复杂。
- 散列函数生成的值要尽可能随机并且均匀分布

**装载因子**

装载因子表示散列表中空位的多少。

散列表的装载因子=填入表中的元素个数/散列表的长度。

装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。


**散列表扩容**

装载因子过大，导致散列冲突增多，散列表的性能下降。

因此，需要设置一个阈值，当散列表的装载因子超过阈值时，就需要进行扩容。

如果内存空间不紧张，对执行效率要求很高，可以降低阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加阈值的值，甚至可以大于 1。

插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。

在扩容时进行全迁移，会导致这一次插入操作异常卡顿。可以使用分步迁移策略分摊掉迁移成本
- 当装载因子触达阈值之后，只申请新空间
- 每插入一个新数据，将新数据插入新散列表，并且从旧散列表中迁移一个数据到新散列表
- 查询时，先从新散列表查找，再从旧散列表查找

**选择冲突解决方法**

开放寻址法，完全基于数组，因此适合数据量比较小、装载因子小的情况。

基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。


**Java HashMap的设计**

- 初始大小：HashMap 默认的初始大小是 16，可根据通过具体场景自行设置
- 装载因子+动态扩容策略：最大装载因子是0.75，当 HashMap 中元素个数超过 0.75*capacity就会自动扩容，扩容为原来的两倍大小
- 冲突解决方法：使用链表法。链表长度太长（默认超过 8）时，将链表转换为红黑树；当红黑树结点小于8个，转换回链表。
- 散列函数
    ``` java
    int hash(Object key) {
        int h = key.hashCode()；
        return (h ^ (h >>> 16)) & (capicity -1); //capicity表示散列表的大小
    }
    ```