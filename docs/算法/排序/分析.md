---
title: 排序分析
permalink: /algo/sort-analyze
---

# 排序分析

## 如何分析一个“排序算法”？

- 排序算法的执行效率
    - 最好情况、最坏情况、平均情况时间复杂度（数据有序度不同）
    - 时间复杂度的系数、常数 、低阶（实际应用中，数据规模比较小，同阶比较需要考虑）
    - 比较和移动的次数
- 内存消耗（原地排序：空间复杂度是$O(1)$）
- 稳定性（经过一次排序之后，相等元素之间原有先后顺序不变）（应用场景：先按下单时间排序，再按订单金额排序）

## 冒泡排序

``` js
/**
 * @param {number[]} nums
 * @return {number[]}
 */

// 冒泡排序
var sortArray = function(nums) {
    const len = nums.length;
    for (let i = 0; i < len; i++) {
        let flag = false;
        for (let j = 0; j < len - i - 1; j++) {
            if (nums[j] > nums[j+1]) {
                [nums[j], nums[j+1]] = [nums[j+1], nums[j]];
                flag = true;
            }
        }
        if (!flag) {
            break;
        }
    }
    return nums;
};

```

### 稳定性

稳定排序

### 空间复杂度

原地排序

### 时间复杂度

最好情况时间复杂度：$O(n)$

最坏时间复杂度：$O(n^2)$

**如何计算平均复杂度**

有序度是数组中具有有序关系的元素对的个数。

完全有序的数组的有序度叫作满有序度。

逆序度 = 满有序度 - 有序度

排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。

例如：4，5，6，3，2，1

有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。

n=6，所以排序完成之后终态的满有序度为 n*(n-1)/2=15。

逆序度 = 15 - 3 = 12，即要进行 12 次交换操作。

回到计算平均复杂度，在冒泡排序中，最好的情况对应的初始有序度是$n*(n-1)/2$，最坏的情况对应的初始有序度是0。

取中间值$n*(n-1)/4$，所以逆序度是$n*(n-1)/2 - n*(n-1)/4 = n*(n-1)/4$，平均情况下的时间复杂度是$O(n^2)$


## 插入排序

``` js

/**
 * @param {number[]} nums
 * @return {number[]}
 */

// 插入排序
var sortArray = function(nums) {
    const n = nums.length;
    for (let i = 1; i < n ; i++) {
        const value = nums[i];
        let j = i - 1;
        for (; j >= 0; j--) {
            if (nums[j] > value) {
                nums[j + 1] = nums[j];
            } else {
                break;
            }
        }
        nums[j + 1] = value;
    }
    return nums;
};

```


### 稳定性

稳定排序

### 空间复杂度

原地排序

### 时间复杂度

最好时间复杂度：$O(n)$

最坏时间复杂度：$O(n^2)$

平均时间复杂度：$O(n^2)$


## 选择排序

``` js
/**
 * @param {number[]} nums
 * @return {number[]}
 */

// 选择排序
var sortArray = function(nums) {
    const n = nums.length;

    for (let i = 0; i < n; i++) {
        let minIndex = i;
        for (let j = i + 1; j < n; j++) {
            if (nums[j] < nums[minIndex]) {
                minIndex = j;
            }
        }
        [nums[i], nums[minIndex]] = [nums[minIndex], nums[i]];
    }
    return nums;
};

```

### 稳定性

非稳定排序，和最小值交换位置会打乱元素原有先后顺序。

### 空间复杂度

原地排序

### 时间复杂度

最好时间复杂度：$O(n^2)$

最坏时间复杂度：$O(n^2)$

平均时间复杂度：$O(n^2)$

## 归并排序

分治是一种解决问题的处理思想，递归是一种编程技巧。


### 稳定性

稳定算法

### 空间复杂度

$O(n)$

### 时间复杂度

最好时间复杂度：$O(nlogn)$

最坏时间复杂度：$O(nlogn)$

平均时间复杂度：$O(nlogn)$

**如何分析递归代码的时间复杂度？**

递归的时间复杂度也符合递推公式。
归并的过程：均分为两个子数组排序，再合并

$T(n) = T(n/2) + T(n/2) + n$

$T(1) = C$

``` 
T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
     ......
     = 2^k * T(n/2^k) + k * n
     ......
```

$T(n) = 2^k * T(n/2^k) + k * n$
$T(1) = 2^k * T(1/2^k) + k = 1$


## 快速排序


### 稳定性

非稳定算法

### 空间复杂度

原地排序

### 时间复杂度

T(n) 在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n2)。


## 桶排序

## 计数排序

## 基数排序